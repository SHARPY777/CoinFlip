"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rpc-websockets";
exports.ids = ["vendor-chunks/rpc-websockets"];
exports.modules = {

/***/ "(ssr)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/eventemitter3/index.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("\nvar has = Object.prototype.hasOwnProperty, prefix = \"~\";\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */ function Events() {}\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n    Events.prototype = Object.create(null);\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new Events().__proto__) prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */ function EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */ function addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"The listener must be a function\");\n    }\n    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n    else emitter._events[evt] = [\n        emitter._events[evt],\n        listener\n    ];\n    return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */ function clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new Events();\n    else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */ function EventEmitter() {\n    this._events = new Events();\n    this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */ EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0) return names;\n    for(name in events = this._events){\n        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n    }\n    if (Object.getOwnPropertySymbols) {\n        return names.concat(Object.getOwnPropertySymbols(events));\n    }\n    return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */ EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = prefix ? prefix + event : event, handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [\n        handlers.fn\n    ];\n    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++){\n        ee[i] = handlers[i].fn;\n    }\n    return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */ EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = prefix ? prefix + event : event, listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n        switch(len){\n            case 1:\n                return listeners.fn.call(listeners.context), true;\n            case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n        for(i = 1, args = new Array(len - 1); i < len; i++){\n            args[i - 1] = arguments[i];\n        }\n        listeners.fn.apply(listeners.context, args);\n    } else {\n        var length = listeners.length, j;\n        for(i = 0; i < length; i++){\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch(len){\n                case 1:\n                    listeners[i].fn.call(listeners[i].context);\n                    break;\n                case 2:\n                    listeners[i].fn.call(listeners[i].context, a1);\n                    break;\n                case 3:\n                    listeners[i].fn.call(listeners[i].context, a1, a2);\n                    break;\n                case 4:\n                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                    break;\n                default:\n                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++){\n                        args[j - 1] = arguments[j];\n                    }\n                    listeners[i].fn.apply(listeners[i].context, args);\n            }\n        }\n    }\n    return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ EventEmitter.prototype.on = function on(event, fn, context) {\n    return addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ EventEmitter.prototype.once = function once(event, fn, context) {\n    return addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt]) return this;\n    if (!fn) {\n        clearEvent(this, evt);\n        return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n            clearEvent(this, evt);\n        }\n    } else {\n        for(var i = 0, events = [], length = listeners.length; i < length; i++){\n            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n                events.push(listeners[i]);\n            }\n        }\n        //\n        // Reset the array, or remove it completely if we have no more listeners.\n        //\n        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n        else clearEvent(this, evt);\n    }\n    return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n        evt = prefix ? prefix + event : event;\n        if (this._events[evt]) clearEvent(this, evt);\n    } else {\n        this._events = new Events();\n        this._eventsCount = 0;\n    }\n    return this;\n};\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n//\n// Expose the module.\n//\nif (true) {\n    module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxNQUFNQyxPQUFPQyxTQUFTLENBQUNDLGNBQWMsRUFDckNDLFNBQVM7QUFFYjs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxVQUFVO0FBRW5CLEVBQUU7QUFDRiw2RUFBNkU7QUFDN0UsOEVBQThFO0FBQzlFLDZFQUE2RTtBQUM3RSxxRUFBcUU7QUFDckUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixJQUFJSixPQUFPSyxNQUFNLEVBQUU7SUFDakJELE9BQU9ILFNBQVMsR0FBR0QsT0FBT0ssTUFBTSxDQUFDO0lBRWpDLEVBQUU7SUFDRiw2RUFBNkU7SUFDN0UsdUVBQXVFO0lBQ3ZFLEVBQUU7SUFDRixJQUFJLENBQUMsSUFBSUQsU0FBU0UsU0FBUyxFQUFFSCxTQUFTO0FBQ3hDO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTSSxHQUFHQyxFQUFFLEVBQUVDLE9BQU8sRUFBRUMsSUFBSTtJQUMzQixJQUFJLENBQUNGLEVBQUUsR0FBR0E7SUFDVixJQUFJLENBQUNDLE9BQU8sR0FBR0E7SUFDZixJQUFJLENBQUNDLElBQUksR0FBR0EsUUFBUTtBQUN0QjtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTQyxZQUFZQyxPQUFPLEVBQUVDLEtBQUssRUFBRUwsRUFBRSxFQUFFQyxPQUFPLEVBQUVDLElBQUk7SUFDcEQsSUFBSSxPQUFPRixPQUFPLFlBQVk7UUFDNUIsTUFBTSxJQUFJTSxVQUFVO0lBQ3RCO0lBRUEsSUFBSUMsV0FBVyxJQUFJUixHQUFHQyxJQUFJQyxXQUFXRyxTQUFTRixPQUMxQ00sTUFBTWIsU0FBU0EsU0FBU1UsUUFBUUE7SUFFcEMsSUFBSSxDQUFDRCxRQUFRSyxPQUFPLENBQUNELElBQUksRUFBRUosUUFBUUssT0FBTyxDQUFDRCxJQUFJLEdBQUdELFVBQVVILFFBQVFNLFlB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bm9kZV9tb2R1bGVzL3JwYy13ZWJzb2NrZXRzL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzPzVjYzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbImhhcyIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicHJlZml4IiwiRXZlbnRzIiwiY3JlYXRlIiwiX19wcm90b19fIiwiRUUiLCJmbiIsImNvbnRleHQiLCJvbmNlIiwiYWRkTGlzdGVuZXIiLCJlbWl0dGVyIiwiZXZlbnQiLCJUeXBlRXJyb3IiLCJsaXN0ZW5lciIsImV2dCIsIl9ldmVudHMiLCJfZXZlbnRzQ291bnQiLCJwdXNoIiwiY2xlYXJFdmVudCIsIkV2ZW50RW1pdHRlciIsImV2ZW50TmFtZXMiLCJuYW1lcyIsImV2ZW50cyIsIm5hbWUiLCJjYWxsIiwic2xpY2UiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJjb25jYXQiLCJsaXN0ZW5lcnMiLCJoYW5kbGVycyIsImkiLCJsIiwibGVuZ3RoIiwiZWUiLCJBcnJheSIsImxpc3RlbmVyQ291bnQiLCJlbWl0IiwiYTEiLCJhMiIsImEzIiwiYTQiLCJhNSIsImxlbiIsImFyZ3VtZW50cyIsImFyZ3MiLCJyZW1vdmVMaXN0ZW5lciIsInVuZGVmaW5lZCIsImFwcGx5IiwiaiIsIm9uIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwib2ZmIiwicHJlZml4ZWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rpc-websockets/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/rpc-websockets/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   CommonClient: () => (/* binding */ CommonClient),\n/* harmony export */   DefaultDataPack: () => (/* binding */ DefaultDataPack),\n/* harmony export */   Server: () => (/* binding */ Server),\n/* harmony export */   WebSocket: () => (/* binding */ WebSocket),\n/* harmony export */   createError: () => (/* binding */ createError)\n/* harmony export */ });\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ \"(ssr)/./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/v1.js\");\n\n\n\n\n// src/lib/client/websocket.ts\nfunction WebSocket(address, options) {\n    return new ws__WEBPACK_IMPORTED_MODULE_0__[\"default\"](address, options);\n}\n// src/lib/utils.ts\nvar DefaultDataPack = class {\n    encode(value) {\n        return JSON.stringify(value);\n    }\n    decode(value) {\n        return JSON.parse(value);\n    }\n};\n// src/lib/client.ts\nvar CommonClient = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n    /**\n  * Instantiate a Client class.\n  * @constructor\n  * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n  * @param {String} address - url to a websocket server\n  * @param {Object} options - ws options object with reconnect parameters\n  * @param {Function} generate_request_id - custom generation request Id\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {CommonClient}\n  */ constructor(webSocketFactory, address = \"ws://localhost:8080\", { autoconnect = true, reconnect = true, reconnect_interval = 1e3, max_reconnects = 5, ...rest_options } = {}, generate_request_id, dataPack){\n        super();\n        this.webSocketFactory = webSocketFactory;\n        this.queue = {};\n        this.rpc_id = 0;\n        this.address = address;\n        this.autoconnect = autoconnect;\n        this.ready = false;\n        this.reconnect = reconnect;\n        this.reconnect_timer_id = void 0;\n        this.reconnect_interval = reconnect_interval;\n        this.max_reconnects = max_reconnects;\n        this.rest_options = rest_options;\n        this.current_reconnects = 0;\n        this.generate_request_id = generate_request_id || (()=>++this.rpc_id);\n        if (!dataPack) this.dataPack = new DefaultDataPack();\n        else this.dataPack = dataPack;\n        if (this.autoconnect) this._connect(this.address, {\n            autoconnect: this.autoconnect,\n            reconnect: this.reconnect,\n            reconnect_interval: this.reconnect_interval,\n            max_reconnects: this.max_reconnects,\n            ...this.rest_options\n        });\n    }\n    /**\n  * Connects to a defined server if not connected already.\n  * @method\n  * @return {Undefined}\n  */ connect() {\n        if (this.socket) return;\n        this._connect(this.address, {\n            autoconnect: this.autoconnect,\n            reconnect: this.reconnect,\n            reconnect_interval: this.reconnect_interval,\n            max_reconnects: this.max_reconnects,\n            ...this.rest_options\n        });\n    }\n    /**\n  * Calls a registered RPC method on server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object|Array} params - optional method parameters\n  * @param {Number} timeout - RPC reply timeout value\n  * @param {Object} ws_opts - options passed to ws\n  * @return {Promise}\n  */ call(method, params, timeout, ws_opts) {\n        if (!ws_opts && \"object\" === typeof timeout) {\n            ws_opts = timeout;\n            timeout = null;\n        }\n        return new Promise((resolve, reject)=>{\n            if (!this.ready) return reject(new Error(\"socket not ready\"));\n            const rpc_id = this.generate_request_id(method, params);\n            const message = {\n                jsonrpc: \"2.0\",\n                method,\n                params: params || void 0,\n                id: rpc_id\n            };\n            this.socket.send(this.dataPack.encode(message), ws_opts, (error)=>{\n                if (error) return reject(error);\n                this.queue[rpc_id] = {\n                    promise: [\n                        resolve,\n                        reject\n                    ]\n                };\n                if (timeout) {\n                    this.queue[rpc_id].timeout = setTimeout(()=>{\n                        delete this.queue[rpc_id];\n                        reject(new Error(\"reply timeout\"));\n                    }, timeout);\n                }\n            });\n        });\n    }\n    /**\n  * Logins with the other side of the connection.\n  * @method\n  * @param {Object} params - Login credentials object\n  * @return {Promise}\n  */ async login(params) {\n        const resp = await this.call(\"rpc.login\", params);\n        if (!resp) throw new Error(\"authentication failed\");\n        return resp;\n    }\n    /**\n  * Fetches a list of client's methods registered on server.\n  * @method\n  * @return {Array}\n  */ async listMethods() {\n        return await this.call(\"__listMethods\");\n    }\n    /**\n  * Sends a JSON-RPC 2.0 notification to server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object} params - optional method parameters\n  * @return {Promise}\n  */ notify(method, params) {\n        return new Promise((resolve, reject)=>{\n            if (!this.ready) return reject(new Error(\"socket not ready\"));\n            const message = {\n                jsonrpc: \"2.0\",\n                method,\n                params\n            };\n            this.socket.send(this.dataPack.encode(message), (error)=>{\n                if (error) return reject(error);\n                resolve();\n            });\n        });\n    }\n    /**\n  * Subscribes for a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */ async subscribe(event) {\n        if (typeof event === \"string\") event = [\n            event\n        ];\n        const result = await this.call(\"rpc.on\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n        return result;\n    }\n    /**\n  * Unsubscribes from a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */ async unsubscribe(event) {\n        if (typeof event === \"string\") event = [\n            event\n        ];\n        const result = await this.call(\"rpc.off\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed unsubscribing from an event with: \" + result);\n        return result;\n    }\n    /**\n  * Closes a WebSocket connection gracefully.\n  * @method\n  * @param {Number} code - socket close code\n  * @param {String} data - optional data to be sent before closing\n  * @return {Undefined}\n  */ close(code, data) {\n        this.socket.close(code || 1e3, data);\n    }\n    /**\n  * Enable / disable automatic reconnection.\n  * @method\n  * @param {Boolean} reconnect - enable / disable reconnection\n  * @return {Undefined}\n  */ setAutoReconnect(reconnect) {\n        this.reconnect = reconnect;\n    }\n    /**\n  * Set the interval between reconnection attempts.\n  * @method\n  * @param {Number} interval - reconnection interval in milliseconds\n  * @return {Undefined}\n  */ setReconnectInterval(interval) {\n        this.reconnect_interval = interval;\n    }\n    /**\n  * Set the maximum number of reconnection attempts.\n  * @method\n  * @param {Number} max_reconnects - maximum reconnection attempts\n  * @return {Undefined}\n  */ setMaxReconnects(max_reconnects) {\n        this.max_reconnects = max_reconnects;\n    }\n    /**\n  * Connection/Message handler.\n  * @method\n  * @private\n  * @param {String} address - WebSocket API address\n  * @param {Object} options - ws options object\n  * @return {Undefined}\n  */ _connect(address, options) {\n        clearTimeout(this.reconnect_timer_id);\n        this.socket = this.webSocketFactory(address, options);\n        this.socket.addEventListener(\"open\", ()=>{\n            this.ready = true;\n            this.emit(\"open\");\n            this.current_reconnects = 0;\n        });\n        this.socket.addEventListener(\"message\", ({ data: message })=>{\n            if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();\n            try {\n                message = this.dataPack.decode(message);\n            } catch (error) {\n                return;\n            }\n            if (message.notification && this.listeners(message.notification).length) {\n                if (!Object.keys(message.params).length) return this.emit(message.notification);\n                const args = [\n                    message.notification\n                ];\n                if (message.params.constructor === Object) args.push(message.params);\n                else for(let i = 0; i < message.params.length; i++)args.push(message.params[i]);\n                return Promise.resolve().then(()=>{\n                    this.emit.apply(this, args);\n                });\n            }\n            if (!this.queue[message.id]) {\n                if (message.method) {\n                    return Promise.resolve().then(()=>{\n                        this.emit(message.method, message?.params);\n                    });\n                }\n                return;\n            }\n            if (\"error\" in message === \"result\" in message) this.queue[message.id].promise[1](new Error('Server response malformed. Response must include either \"result\" or \"error\", but not both.'));\n            if (this.queue[message.id].timeout) clearTimeout(this.queue[message.id].timeout);\n            if (message.error) this.queue[message.id].promise[1](message.error);\n            else this.queue[message.id].promise[0](message.result);\n            delete this.queue[message.id];\n        });\n        this.socket.addEventListener(\"error\", (error)=>this.emit(\"error\", error));\n        this.socket.addEventListener(\"close\", ({ code, reason })=>{\n            if (this.ready) setTimeout(()=>this.emit(\"close\", code, reason), 0);\n            this.ready = false;\n            this.socket = void 0;\n            if (code === 1e3) return;\n            this.current_reconnects++;\n            if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0)) this.reconnect_timer_id = setTimeout(()=>this._connect(address, options), this.reconnect_interval);\n        });\n    }\n};\nvar Server = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n    /**\n  * Instantiate a Server class.\n  * @constructor\n  * @param {Object} options - ws constructor's parameters with rpc\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {Server} - returns a new Server instance\n  */ constructor(options, dataPack){\n        super();\n        this.namespaces = {};\n        if (!dataPack) this.dataPack = new DefaultDataPack();\n        else this.dataPack = dataPack;\n        this.wss = new ws__WEBPACK_IMPORTED_MODULE_0__.WebSocketServer(options);\n        this.wss.on(\"listening\", ()=>this.emit(\"listening\"));\n        this.wss.on(\"connection\", (socket, request)=>{\n            const u = node_url__WEBPACK_IMPORTED_MODULE_2__.parse(request.url, true);\n            const ns = u.pathname;\n            if (u.query.socket_id) socket._id = u.query.socket_id;\n            else socket._id = (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n            socket[\"_authenticated\"] = false;\n            socket.on(\"error\", (error)=>this.emit(\"socket-error\", socket, error));\n            socket.on(\"close\", ()=>{\n                this.namespaces[ns].clients.delete(socket._id);\n                for (const event of Object.keys(this.namespaces[ns].events)){\n                    const index = this.namespaces[ns].events[event].sockets.indexOf(socket._id);\n                    if (index >= 0) this.namespaces[ns].events[event].sockets.splice(index, 1);\n                }\n                this.emit(\"disconnection\", socket);\n            });\n            if (!this.namespaces[ns]) this._generateNamespace(ns);\n            this.namespaces[ns].clients.set(socket._id, socket);\n            this.emit(\"connection\", socket, request);\n            return this._handleRPC(socket, ns);\n        });\n        this.wss.on(\"error\", (error)=>this.emit(\"error\", error));\n    }\n    /**\n  * Registers an RPC method.\n  * @method\n  * @param {String} name - method name\n  * @param {Function} fn - a callee function\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IMethod object\n  */ register(name, fn, ns = \"/\") {\n        if (!this.namespaces[ns]) this._generateNamespace(ns);\n        this.namespaces[ns].rpc_methods[name] = {\n            fn,\n            protected: false\n        };\n        return {\n            protected: ()=>this._makeProtectedMethod(name, ns),\n            public: ()=>this._makePublicMethod(name, ns)\n        };\n    }\n    /**\n  * Sets an auth method.\n  * @method\n  * @param {Function} fn - an arbitrary auth method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */ setAuth(fn, ns = \"/\") {\n        this.register(\"rpc.login\", fn, ns);\n    }\n    /**\n  * Marks an RPC method as protected.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makeProtectedMethod(name, ns = \"/\") {\n        this.namespaces[ns].rpc_methods[name].protected = true;\n    }\n    /**\n  * Marks an RPC method as public.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makePublicMethod(name, ns = \"/\") {\n        this.namespaces[ns].rpc_methods[name].protected = false;\n    }\n    /**\n  * Marks an event as protected.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makeProtectedEvent(name, ns = \"/\") {\n        this.namespaces[ns].events[name].protected = true;\n    }\n    /**\n  * Marks an event as public.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makePublicEvent(name, ns = \"/\") {\n        this.namespaces[ns].events[name].protected = false;\n    }\n    /**\n  * Removes a namespace and closes all connections\n  * @method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */ closeNamespace(ns) {\n        const namespace = this.namespaces[ns];\n        if (namespace) {\n            delete namespace.rpc_methods;\n            delete namespace.events;\n            for (const socket of namespace.clients.values())socket.close();\n            delete this.namespaces[ns];\n        }\n    }\n    /**\n  * Creates a new event that can be emitted to clients.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IEvent object\n  */ event(name, ns = \"/\") {\n        if (!this.namespaces[ns]) this._generateNamespace(ns);\n        else {\n            const index = this.namespaces[ns].events[name];\n            if (index !== void 0) throw new Error(`Already registered event ${ns}${name}`);\n        }\n        this.namespaces[ns].events[name] = {\n            sockets: [],\n            protected: false\n        };\n        this.on(name, (...params)=>{\n            if (params.length === 1 && params[0] instanceof Object) params = params[0];\n            for (const socket_id of this.namespaces[ns].events[name].sockets){\n                const socket = this.namespaces[ns].clients.get(socket_id);\n                if (!socket) continue;\n                socket.send(this.dataPack.encode({\n                    notification: name,\n                    params\n                }));\n            }\n        });\n        return {\n            protected: ()=>this._makeProtectedEvent(name, ns),\n            public: ()=>this._makePublicEvent(name, ns)\n        };\n    }\n    /**\n  * Returns a requested namespace object\n  * @method\n  * @param {String} name - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - namespace object\n  */ of(name) {\n        if (!this.namespaces[name]) this._generateNamespace(name);\n        const self = this;\n        return {\n            // self.register convenience method\n            register (fn_name, fn) {\n                if (arguments.length !== 2) throw new Error(\"must provide exactly two arguments\");\n                if (typeof fn_name !== \"string\") throw new Error(\"name must be a string\");\n                if (typeof fn !== \"function\") throw new Error(\"handler must be a function\");\n                return self.register(fn_name, fn, name);\n            },\n            // self.event convenience method\n            event (ev_name) {\n                if (arguments.length !== 1) throw new Error(\"must provide exactly one argument\");\n                if (typeof ev_name !== \"string\") throw new Error(\"name must be a string\");\n                return self.event(ev_name, name);\n            },\n            // self.eventList convenience method\n            get eventList () {\n                return Object.keys(self.namespaces[name].events);\n            },\n            /**\n      * Emits a specified event to this namespace.\n      * @inner\n      * @method\n      * @param {String} event - event name\n      * @param {Array} params - event parameters\n      * @return {Undefined}\n      */ emit (event, ...params) {\n                const socket_ids = [\n                    ...self.namespaces[name].clients.keys()\n                ];\n                for(let i = 0, id; id = socket_ids[i]; ++i){\n                    self.namespaces[name].clients.get(id).send(self.dataPack.encode({\n                        notification: event,\n                        params: params || []\n                    }));\n                }\n            },\n            /**\n      * Returns a name of this namespace.\n      * @inner\n      * @method\n      * @kind constant\n      * @return {String}\n      */ get name () {\n                return name;\n            },\n            /**\n      * Returns a hash of websocket objects connected to this namespace.\n      * @inner\n      * @method\n      * @return {Object}\n      */ connected () {\n                const socket_ids = [\n                    ...self.namespaces[name].clients.keys()\n                ];\n                return socket_ids.reduce((acc, curr)=>({\n                        ...acc,\n                        [curr]: self.namespaces[name].clients.get(curr)\n                    }), {});\n            },\n            /**\n      * Returns a list of client unique identifiers connected to this namespace.\n      * @inner\n      * @method\n      * @return {Array}\n      */ clients () {\n                return self.namespaces[name];\n            }\n        };\n    }\n    /**\n  * Lists all created events in a given namespace. Defaults to \"/\".\n  * @method\n  * @param {String} ns - namespaces identifier\n  * @readonly\n  * @return {Array} - returns a list of created events\n  */ eventList(ns = \"/\") {\n        if (!this.namespaces[ns]) return [];\n        return Object.keys(this.namespaces[ns].events);\n    }\n    /**\n  * Creates a JSON-RPC 2.0 compliant error\n  * @method\n  * @param {Number} code - indicates the error type that occurred\n  * @param {String} message - provides a short description of the error\n  * @param {String|Object} data - details containing additional information about the error\n  * @return {Object}\n  */ createError(code, message, data) {\n        return {\n            code,\n            message,\n            data: data || null\n        };\n    }\n    /**\n  * Closes the server and terminates all clients.\n  * @method\n  * @return {Promise}\n  */ close() {\n        return new Promise((resolve, reject)=>{\n            try {\n                this.wss.close();\n                this.emit(\"close\");\n                resolve();\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n    /**\n  * Handles all WebSocket JSON RPC 2.0 requests.\n  * @private\n  * @param {Object} socket - ws socket instance\n  * @param {String} ns - namespaces identifier\n  * @return {Undefined}\n  */ _handleRPC(socket, ns = \"/\") {\n        socket.on(\"message\", async (data)=>{\n            const msg_options = {};\n            if (data instanceof ArrayBuffer) {\n                msg_options.binary = true;\n                data = Buffer.from(data).toString();\n            }\n            if (socket.readyState !== 1) return;\n            let parsedData;\n            try {\n                parsedData = this.dataPack.decode(data);\n            } catch (error) {\n                return socket.send(this.dataPack.encode({\n                    jsonrpc: \"2.0\",\n                    error: createError(-32700, error.toString()),\n                    id: null\n                }), msg_options);\n            }\n            if (Array.isArray(parsedData)) {\n                if (!parsedData.length) return socket.send(this.dataPack.encode({\n                    jsonrpc: \"2.0\",\n                    error: createError(-32600, \"Invalid array\"),\n                    id: null\n                }), msg_options);\n                const responses = [];\n                for (const message of parsedData){\n                    const response2 = await this._runMethod(message, socket._id, ns);\n                    if (!response2) continue;\n                    responses.push(response2);\n                }\n                if (!responses.length) return;\n                return socket.send(this.dataPack.encode(responses), msg_options);\n            }\n            const response = await this._runMethod(parsedData, socket._id, ns);\n            if (!response) return;\n            return socket.send(this.dataPack.encode(response), msg_options);\n        });\n    }\n    /**\n  * Runs a defined RPC method.\n  * @private\n  * @param {Object} message - a message received\n  * @param {Object} socket_id - user's socket id\n  * @param {String} ns - namespaces identifier\n  * @return {Object|undefined}\n  */ async _runMethod(message, socket_id, ns = \"/\") {\n        if (typeof message !== \"object\" || message === null) return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600),\n            id: null\n        };\n        if (message.jsonrpc !== \"2.0\") return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600, \"Invalid JSON RPC version\"),\n            id: message.id || null\n        };\n        if (!message.method) return {\n            jsonrpc: \"2.0\",\n            error: createError(-32602, \"Method not specified\"),\n            id: message.id || null\n        };\n        if (typeof message.method !== \"string\") return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600, \"Invalid method name\"),\n            id: message.id || null\n        };\n        if (message.params && typeof message.params === \"string\") return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600),\n            id: message.id || null\n        };\n        if (message.method === \"rpc.on\") {\n            if (!message.params) return {\n                jsonrpc: \"2.0\",\n                error: createError(-32e3),\n                id: message.id || null\n            };\n            const results = {};\n            const event_names = Object.keys(this.namespaces[ns].events);\n            for (const name of message.params){\n                const index = event_names.indexOf(name);\n                const namespace = this.namespaces[ns];\n                if (index === -1) {\n                    results[name] = \"provided event invalid\";\n                    continue;\n                }\n                if (namespace.events[event_names[index]].protected === true && namespace.clients.get(socket_id)[\"_authenticated\"] === false) {\n                    return {\n                        jsonrpc: \"2.0\",\n                        error: createError(-32606),\n                        id: message.id || null\n                    };\n                }\n                const socket_index = namespace.events[event_names[index]].sockets.indexOf(socket_id);\n                if (socket_index >= 0) {\n                    results[name] = \"socket has already been subscribed to event\";\n                    continue;\n                }\n                namespace.events[event_names[index]].sockets.push(socket_id);\n                results[name] = \"ok\";\n            }\n            return {\n                jsonrpc: \"2.0\",\n                result: results,\n                id: message.id || null\n            };\n        } else if (message.method === \"rpc.off\") {\n            if (!message.params) return {\n                jsonrpc: \"2.0\",\n                error: createError(-32e3),\n                id: message.id || null\n            };\n            const results = {};\n            for (const name of message.params){\n                if (!this.namespaces[ns].events[name]) {\n                    results[name] = \"provided event invalid\";\n                    continue;\n                }\n                const index = this.namespaces[ns].events[name].sockets.indexOf(socket_id);\n                if (index === -1) {\n                    results[name] = \"not subscribed\";\n                    continue;\n                }\n                this.namespaces[ns].events[name].sockets.splice(index, 1);\n                results[name] = \"ok\";\n            }\n            return {\n                jsonrpc: \"2.0\",\n                result: results,\n                id: message.id || null\n            };\n        } else if (message.method === \"rpc.login\") {\n            if (!message.params) return {\n                jsonrpc: \"2.0\",\n                error: createError(-32604),\n                id: message.id || null\n            };\n        }\n        if (!this.namespaces[ns].rpc_methods[message.method]) {\n            return {\n                jsonrpc: \"2.0\",\n                error: createError(-32601),\n                id: message.id || null\n            };\n        }\n        let response = null;\n        if (this.namespaces[ns].rpc_methods[message.method].protected === true && this.namespaces[ns].clients.get(socket_id)[\"_authenticated\"] === false) {\n            return {\n                jsonrpc: \"2.0\",\n                error: createError(-32605),\n                id: message.id || null\n            };\n        }\n        try {\n            response = await this.namespaces[ns].rpc_methods[message.method].fn(message.params, socket_id);\n        } catch (error) {\n            if (!message.id) return;\n            if (error instanceof Error) return {\n                jsonrpc: \"2.0\",\n                error: {\n                    code: -32e3,\n                    message: error.name,\n                    data: error.message\n                },\n                id: message.id\n            };\n            return {\n                jsonrpc: \"2.0\",\n                error,\n                id: message.id\n            };\n        }\n        if (!message.id) return;\n        if (message.method === \"rpc.login\" && response === true) {\n            const s = this.namespaces[ns].clients.get(socket_id);\n            s[\"_authenticated\"] = true;\n            this.namespaces[ns].clients.set(socket_id, s);\n        }\n        return {\n            jsonrpc: \"2.0\",\n            result: response,\n            id: message.id\n        };\n    }\n    /**\n  * Generate a new namespace store.\n  * Also preregister some special namespace methods.\n  * @private\n  * @param {String} name - namespaces identifier\n  * @return {undefined}\n  */ _generateNamespace(name) {\n        this.namespaces[name] = {\n            rpc_methods: {\n                __listMethods: {\n                    fn: ()=>Object.keys(this.namespaces[name].rpc_methods),\n                    protected: false\n                }\n            },\n            clients: /* @__PURE__ */ new Map(),\n            events: {}\n        };\n    }\n};\nvar RPC_ERRORS = /* @__PURE__ */ new Map([\n    [\n        -32e3,\n        \"Event not provided\"\n    ],\n    [\n        -32600,\n        \"Invalid Request\"\n    ],\n    [\n        -32601,\n        \"Method not found\"\n    ],\n    [\n        -32602,\n        \"Invalid params\"\n    ],\n    [\n        -32603,\n        \"Internal error\"\n    ],\n    [\n        -32604,\n        \"Params not found\"\n    ],\n    [\n        -32605,\n        \"Method forbidden\"\n    ],\n    [\n        -32606,\n        \"Event forbidden\"\n    ],\n    [\n        -32700,\n        \"Parse error\"\n    ]\n]);\nfunction createError(code, details) {\n    const error = {\n        code,\n        message: RPC_ERRORS.get(code) || \"Internal Server Error\"\n    };\n    if (details) error[\"data\"] = details;\n    return error;\n}\n// src/index.ts\nvar Client = class extends CommonClient {\n    constructor(address = \"ws://localhost:8080\", { autoconnect = true, reconnect = true, reconnect_interval = 1e3, max_reconnects = 5, ...rest_options } = {}, generate_request_id){\n        super(WebSocket, address, {\n            autoconnect,\n            reconnect,\n            reconnect_interval,\n            max_reconnects,\n            ...rest_options\n        }, generate_request_id);\n    }\n};\n //# sourceMappingURL=out.js.map\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNQO0FBQ2xCO0FBQ0Q7QUFFMUIsOEJBQThCO0FBQzlCLFNBQVNLLFVBQVVDLE9BQU8sRUFBRUMsT0FBTztJQUNqQyxPQUFPLElBQUlQLDBDQUFhQSxDQUFDTSxTQUFTQztBQUNwQztBQUVBLG1CQUFtQjtBQUNuQixJQUFJQyxrQkFBa0I7SUFDcEJDLE9BQU9DLEtBQUssRUFBRTtRQUNaLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0Y7SUFDeEI7SUFDQUcsT0FBT0gsS0FBSyxFQUFFO1FBQ1osT0FBT0MsS0FBS0csS0FBSyxDQUFDSjtJQUNwQjtBQUNGO0FBRUEsb0JBQW9CO0FBQ3BCLElBQUlLLGVBQWUsY0FBY2IsdURBQVlBO0lBaUIzQzs7Ozs7Ozs7O0VBU0EsR0FDQWMsWUFBWUMsZ0JBQWdCLEVBQUVYLFVBQVUscUJBQXFCLEVBQUUsRUFDN0RZLGNBQWMsSUFBSSxFQUNsQkMsWUFBWSxJQUFJLEVBQ2hCQyxxQkFBcUIsR0FBRyxFQUN4QkMsaUJBQWlCLENBQUMsRUFDbEIsR0FBR0MsY0FDSixHQUFHLENBQUMsQ0FBQyxFQUFFQyxtQkFBbUIsRUFBRUMsUUFBUSxDQUFFO1FBQ3JDLEtBQUs7UUFDTCxJQUFJLENBQUNQLGdCQUFnQixHQUFHQTtRQUN4QixJQUFJLENBQUNRLEtBQUssR0FBRyxDQUFDO1FBQ2QsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNwQixPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDWSxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ1MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDUixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ1Msa0JBQWtCLEdBQUcsS0FBSztRQUMvQixJQUFJLENBQUNSLGtCQUFrQixHQUFHQTtRQUMxQixJQUFJLENBQUNDLGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDQyxZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ08sa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDTixtQkFBbUIsR0FBR0EsdUJBQXdCLEtBQU0sRUFBRSxJQUFJLENBQUNHLE1BQU07UUFDdEUsSUFBSSxDQUFDRixVQUFVLElBQUksQ0FBQ0EsUUFBUSxHQUFHLElBQUloQjthQUM5QixJQUFJLENBQUNnQixRQUFRLEdBQUdBO1FBQ3JCLElBQUksSUFBSSxDQUFDTixXQUFXLEVBQ2xCLElBQUksQ0FBQ1ksUUFBUSxDQUFDLElBQUksQ0FBQ3hCLE9BQU8sRUFBRTtZQUMxQlksYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFDN0JDLFdBQVcsSUFBSSxDQUFDQSxTQUFTO1lBQ3pCQyxvQkFBb0IsSUFBSSxDQUFDQSxrQkFBa0I7WUFDM0NDLGdCQUFnQixJQUFJLENBQUNBLGNBQWM7WUFDbkMsR0FBRyxJQUFJLENBQUNDLFlBQVk7UUFDdEI7SUFDSjtJQUNBOzs7O0VBSUEsR0FDQVMsVUFBVTtRQUNSLElBQUksSUFBSSxDQUFDQyxNQUFNLEVBQUU7UUFDakIsSUFBSSxDQUFDRixRQUFRLENBQUMsSUFBSSxDQUFDeEIsT0FBTyxFQUFFO1lBQzFCWSxhQUFhLElBQUksQ0FBQ0EsV0FBVztZQUM3QkMsV0FBVyxJQUFJLENBQUNBLFNBQVM7WUFDekJDLG9CQUFvQixJQUFJLENBQUNBLGtCQUFrQjtZQUMzQ0MsZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYztZQUNuQyxHQUFHLElBQUksQ0FBQ0MsWUFBWTtRQUN0QjtJQUNGO0lBQ0E7Ozs7Ozs7O0VBUUEsR0FDQVcsS0FBS0MsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFO1FBQ3JDLElBQUksQ0FBQ0EsV0FBVyxhQUFhLE9BQU9ELFNBQVM7WUFDM0NDLFVBQVVEO1lBQ1ZBLFVBQVU7UUFDWjtRQUNBLE9BQU8sSUFBSUUsUUFBUSxDQUFDQyxTQUFTQztZQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDYixLQUFLLEVBQUUsT0FBT2EsT0FBTyxJQUFJQyxNQUFNO1lBQ3pDLE1BQU1mLFNBQVMsSUFBSSxDQUFDSCxtQkFBbUIsQ0FBQ1csUUFBUUM7WUFDaEQsTUFBTU8sVUFBVTtnQkFDZEMsU0FBUztnQkFDVFQ7Z0JBQ0FDLFFBQVFBLFVBQVUsS0FBSztnQkFDdkJTLElBQUlsQjtZQUNOO1lBQ0EsSUFBSSxDQUFDTSxNQUFNLENBQUNhLElBQUksQ0FBQyxJQUFJLENBQUNyQixRQUFRLENBQUNmLE1BQU0sQ0FBQ2lDLFVBQVVMLFNBQVMsQ0FBQ1M7Z0JBQ3hELElBQUlBLE9BQU8sT0FBT04sT0FBT007Z0JBQ3pCLElBQUksQ0FBQ3JCLEtBQUssQ0FBQ0MsT0FBTyxHQUFHO29CQUFFcUIsU0FBUzt3QkFBQ1I7d0JBQVNDO3FCQUFPO2dCQUFDO2dCQUNsRCxJQUFJSixTQUFTO29CQUNYLElBQUksQ0FBQ1gsS0FBSyxDQUFDQyxPQUFPLENBQUNVLE9BQU8sR0FBR1ksV0FBVzt3QkFDdEMsT0FBTyxJQUFJLENBQUN2QixLQUFLLENBQUNDLE9BQU87d0JBQ3pCYyxPQUFPLElBQUlDLE1BQU07b0JBQ25CLEdBQUdMO2dCQUNMO1lBQ0Y7UUFDRjtJQUNGO0lBQ0E7Ozs7O0VBS0EsR0FDQSxNQUFNYSxNQUFNZCxNQUFNLEVBQUU7UUFDbEIsTUFBTWUsT0FBTyxNQUFNLElBQUksQ0FBQ2pCLElBQUksQ0FBQyxhQUFhRTtRQUMxQyxJQUFJLENBQUNlLE1BQU0sTUFBTSxJQUFJVCxNQUFNO1FBQzNCLE9BQU9TO0lBQ1Q7SUFDQTs7OztFQUlBLEdBQ0EsTUFBTUMsY0FBYztRQUNsQixPQUFPLE1BQU0sSUFBSSxDQUFDbEIsSUFBSSxDQUFDO0lBQ3pCO0lBQ0E7Ozs7OztFQU1BLEdBQ0FtQixPQUFPbEIsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDckIsT0FBTyxJQUFJRyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCLElBQUksQ0FBQyxJQUFJLENBQUNiLEtBQUssRUFBRSxPQUFPYSxPQUFPLElBQUlDLE1BQU07WUFDekMsTUFBTUMsVUFBVTtnQkFDZEMsU0FBUztnQkFDVFQ7Z0JBQ0FDO1lBQ0Y7WUFDQSxJQUFJLENBQUNILE1BQU0sQ0FBQ2EsSUFBSSxDQUFDLElBQUksQ0FBQ3JCLFFBQVEsQ0FBQ2YsTUFBTSxDQUFDaUMsVUFBVSxDQUFDSTtnQkFDL0MsSUFBSUEsT0FBTyxPQUFPTixPQUFPTTtnQkFDekJQO1lBQ0Y7UUFDRjtJQUNGO0lBQ0E7Ozs7OztFQU1BLEdBQ0EsTUFBTWMsVUFBVUMsS0FBSyxFQUFFO1FBQ3JCLElBQUksT0FBT0EsVUFBVSxVQUFVQSxRQUFRO1lBQUNBO1NBQU07UUFDOUMsTUFBTUMsU0FBUyxNQUFNLElBQUksQ0FBQ3RCLElBQUksQ0FBQyxVQUFVcUI7UUFDekMsSUFBSSxPQUFPQSxVQUFVLFlBQVlDLE1BQU0sQ0FBQ0QsTUFBTSxLQUFLLE1BQ2pELE1BQU0sSUFBSWIsTUFDUixxQ0FBcUNhLFFBQVEsYUFBYUMsTUFBTSxDQUFDRCxNQUFNO1FBRTNFLE9BQU9DO0lBQ1Q7SUFDQTs7Ozs7O0VBTUEsR0FDQSxNQUFNQyxZQUFZRixLQUFLLEVBQUU7UUFDdkIsSUFBSSxPQUFPQSxVQUFVLFVBQVVBLFFBQVE7WUFBQ0E7U0FBTTtRQUM5QyxNQUFNQyxTQUFTLE1BQU0sSUFBSSxDQUFDdEIsSUFBSSxDQUFDLFdBQVdxQjtRQUMxQyxJQUFJLE9BQU9BLFVBQVUsWUFBWUMsTUFBTSxDQUFDRCxNQUFNLEtBQUssTUFDakQsTUFBTSxJQUFJYixNQUFNLDhDQUE4Q2M7UUFDaEUsT0FBT0E7SUFDVDtJQUNBOzs7Ozs7RUFNQSxHQUNBRSxNQUFNQyxJQUFJLEVBQUVDLElBQUksRUFBRTtRQUNoQixJQUFJLENBQUMzQixNQUFNLENBQUN5QixLQUFLLENBQUNDLFFBQVEsS0FBS0M7SUFDakM7SUFDQTs7Ozs7RUFLQSxHQUNBQyxpQkFBaUJ6QyxTQUFTLEVBQUU7UUFDMUIsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO0lBQ25CO0lBQ0E7Ozs7O0VBS0EsR0FDQTBDLHFCQUFxQkMsUUFBUSxFQUFFO1FBQzdCLElBQUksQ0FBQzFDLGtCQUFrQixHQUFHMEM7SUFDNUI7SUFDQTs7Ozs7RUFLQSxHQUNBQyxpQkFBaUIxQyxjQUFjLEVBQUU7UUFDL0IsSUFBSSxDQUFDQSxjQUFjLEdBQUdBO0lBQ3hCO0lBQ0E7Ozs7Ozs7RUFPQSxHQUNBUyxTQUFTeEIsT0FBTyxFQUFFQyxPQUFPLEVBQUU7UUFDekJ5RCxhQUFhLElBQUksQ0FBQ3BDLGtCQUFrQjtRQUNwQyxJQUFJLENBQUNJLE1BQU0sR0FBRyxJQUFJLENBQUNmLGdCQUFnQixDQUFDWCxTQUFTQztRQUM3QyxJQUFJLENBQUN5QixNQUFNLENBQUNpQyxnQkFBZ0IsQ0FBQyxRQUFRO1lBQ25DLElBQUksQ0FBQ3RDLEtBQUssR0FBRztZQUNiLElBQUksQ0FBQ3VDLElBQUksQ0FBQztZQUNWLElBQUksQ0FBQ3JDLGtCQUFrQixHQUFHO1FBQzVCO1FBQ0EsSUFBSSxDQUFDRyxNQUFNLENBQUNpQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsRUFBRU4sTUFBTWpCLE9BQU8sRUFBRTtZQUN4RCxJQUFJQSxtQkFBbUJ5QixhQUNyQnpCLFVBQVUwQixPQUFPQyxJQUFJLENBQUMzQixTQUFTNEIsUUFBUTtZQUN6QyxJQUFJO2dCQUNGNUIsVUFBVSxJQUFJLENBQUNsQixRQUFRLENBQUNYLE1BQU0sQ0FBQzZCO1lBQ2pDLEVBQUUsT0FBT0ksT0FBTztnQkFDZDtZQUNGO1lBQ0EsSUFBSUosUUFBUTZCLFlBQVksSUFBSSxJQUFJLENBQUNDLFNBQVMsQ0FBQzlCLFFBQVE2QixZQUFZLEVBQUVFLE1BQU0sRUFBRTtnQkFDdkUsSUFBSSxDQUFDQyxPQUFPQyxJQUFJLENBQUNqQyxRQUFRUCxNQUFNLEVBQUVzQyxNQUFNLEVBQ3JDLE9BQU8sSUFBSSxDQUFDUCxJQUFJLENBQUN4QixRQUFRNkIsWUFBWTtnQkFDdkMsTUFBTUssT0FBTztvQkFBQ2xDLFFBQVE2QixZQUFZO2lCQUFDO2dCQUNuQyxJQUFJN0IsUUFBUVAsTUFBTSxDQUFDbkIsV0FBVyxLQUFLMEQsUUFBUUUsS0FBS0MsSUFBSSxDQUFDbkMsUUFBUVAsTUFBTTtxQkFFakUsSUFBSyxJQUFJMkMsSUFBSSxHQUFHQSxJQUFJcEMsUUFBUVAsTUFBTSxDQUFDc0MsTUFBTSxFQUFFSyxJQUN6Q0YsS0FBS0MsSUFBSSxDQUFDbkMsUUFBUVAsTUFBTSxDQUFDMkMsRUFBRTtnQkFDL0IsT0FBT3hDLFFBQVFDLE9BQU8sR0FBR3dDLElBQUksQ0FBQztvQkFDNUIsSUFBSSxDQUFDYixJQUFJLENBQUNjLEtBQUssQ0FBQyxJQUFJLEVBQUVKO2dCQUN4QjtZQUNGO1lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ25ELEtBQUssQ0FBQ2lCLFFBQVFFLEVBQUUsQ0FBQyxFQUFFO2dCQUMzQixJQUFJRixRQUFRUixNQUFNLEVBQUU7b0JBQ2xCLE9BQU9JLFFBQVFDLE9BQU8sR0FBR3dDLElBQUksQ0FBQzt3QkFDNUIsSUFBSSxDQUFDYixJQUFJLENBQUN4QixRQUFRUixNQUFNLEVBQUVRLFNBQVNQO29CQUNyQztnQkFDRjtnQkFDQTtZQUNGO1lBQ0EsSUFBSSxXQUFXTyxZQUFZLFlBQVlBLFNBQ3JDLElBQUksQ0FBQ2pCLEtBQUssQ0FBQ2lCLFFBQVFFLEVBQUUsQ0FBQyxDQUFDRyxPQUFPLENBQUMsRUFBRSxDQUMvQixJQUFJTixNQUNGO1lBR04sSUFBSSxJQUFJLENBQUNoQixLQUFLLENBQUNpQixRQUFRRSxFQUFFLENBQUMsQ0FBQ1IsT0FBTyxFQUNoQzRCLGFBQWEsSUFBSSxDQUFDdkMsS0FBSyxDQUFDaUIsUUFBUUUsRUFBRSxDQUFDLENBQUNSLE9BQU87WUFDN0MsSUFBSU0sUUFBUUksS0FBSyxFQUFFLElBQUksQ0FBQ3JCLEtBQUssQ0FBQ2lCLFFBQVFFLEVBQUUsQ0FBQyxDQUFDRyxPQUFPLENBQUMsRUFBRSxDQUFDTCxRQUFRSSxLQUFLO2lCQUM3RCxJQUFJLENBQUNyQixLQUFLLENBQUNpQixRQUFRRSxFQUFFLENBQUMsQ0FBQ0csT0FBTyxDQUFDLEVBQUUsQ0FBQ0wsUUFBUWEsTUFBTTtZQUNyRCxPQUFPLElBQUksQ0FBQzlCLEtBQUssQ0FBQ2lCLFFBQVFFLEVBQUUsQ0FBQztRQUMvQjtRQUNBLElBQUksQ0FBQ1osTUFBTSxDQUFDaUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDbkIsUUFBVSxJQUFJLENBQUNvQixJQUFJLENBQUMsU0FBU3BCO1FBQ3BFLElBQUksQ0FBQ2QsTUFBTSxDQUFDaUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLEVBQUVQLElBQUksRUFBRXVCLE1BQU0sRUFBRTtZQUNyRCxJQUFJLElBQUksQ0FBQ3RELEtBQUssRUFDWnFCLFdBQVcsSUFBTSxJQUFJLENBQUNrQixJQUFJLENBQUMsU0FBU1IsTUFBTXVCLFNBQVM7WUFDckQsSUFBSSxDQUFDdEQsS0FBSyxHQUFHO1lBQ2IsSUFBSSxDQUFDSyxNQUFNLEdBQUcsS0FBSztZQUNuQixJQUFJMEIsU0FBUyxLQUFLO1lBQ2xCLElBQUksQ0FBQzdCLGtCQUFrQjtZQUN2QixJQUFJLElBQUksQ0FBQ1YsU0FBUyxJQUFLLEtBQUksQ0FBQ0UsY0FBYyxHQUFHLElBQUksQ0FBQ1Esa0JBQWtCLElBQUksSUFBSSxDQUFDUixjQUFjLEtBQUssSUFDOUYsSUFBSSxDQUFDTyxrQkFBa0IsR0FBR29CLFdBQ3hCLElBQU0sSUFBSSxDQUFDbEIsUUFBUSxDQUFDeEIsU0FBU0MsVUFDN0IsSUFBSSxDQUFDYSxrQkFBa0I7UUFFN0I7SUFDRjtBQUNGO0FBQ0EsSUFBSThELFNBQVMsY0FBY2hGLHVEQUFZQTtJQUlyQzs7Ozs7O0VBTUEsR0FDQWMsWUFBWVQsT0FBTyxFQUFFaUIsUUFBUSxDQUFFO1FBQzdCLEtBQUs7UUFDTCxJQUFJLENBQUMyRCxVQUFVLEdBQUcsQ0FBQztRQUNuQixJQUFJLENBQUMzRCxVQUFVLElBQUksQ0FBQ0EsUUFBUSxHQUFHLElBQUloQjthQUM5QixJQUFJLENBQUNnQixRQUFRLEdBQUdBO1FBQ3JCLElBQUksQ0FBQzRELEdBQUcsR0FBRyxJQUFJbkYsK0NBQWVBLENBQUNNO1FBQy9CLElBQUksQ0FBQzZFLEdBQUcsQ0FBQ0MsRUFBRSxDQUFDLGFBQWEsSUFBTSxJQUFJLENBQUNuQixJQUFJLENBQUM7UUFDekMsSUFBSSxDQUFDa0IsR0FBRyxDQUFDQyxFQUFFLENBQUMsY0FBYyxDQUFDckQsUUFBUXNEO1lBQ2pDLE1BQU1DLElBQUlwRiwyQ0FBUyxDQUFDbUYsUUFBUW5GLEdBQUcsRUFBRTtZQUNqQyxNQUFNcUYsS0FBS0QsRUFBRUUsUUFBUTtZQUNyQixJQUFJRixFQUFFRyxLQUFLLENBQUNDLFNBQVMsRUFBRTNELE9BQU80RCxHQUFHLEdBQUdMLEVBQUVHLEtBQUssQ0FBQ0MsU0FBUztpQkFDaEQzRCxPQUFPNEQsR0FBRyxHQUFHeEYsZ0RBQUVBO1lBQ3BCNEIsTUFBTSxDQUFDLGlCQUFpQixHQUFHO1lBQzNCQSxPQUFPcUQsRUFBRSxDQUFDLFNBQVMsQ0FBQ3ZDLFFBQVUsSUFBSSxDQUFDb0IsSUFBSSxDQUFDLGdCQUFnQmxDLFFBQVFjO1lBQ2hFZCxPQUFPcUQsRUFBRSxDQUFDLFNBQVM7Z0JBQ2pCLElBQUksQ0FBQ0YsVUFBVSxDQUFDSyxHQUFHLENBQUNLLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDOUQsT0FBTzRELEdBQUc7Z0JBQzdDLEtBQUssTUFBTXRDLFNBQVNvQixPQUFPQyxJQUFJLENBQUMsSUFBSSxDQUFDUSxVQUFVLENBQUNLLEdBQUcsQ0FBQ08sTUFBTSxFQUFHO29CQUMzRCxNQUFNQyxRQUFRLElBQUksQ0FBQ2IsVUFBVSxDQUFDSyxHQUFHLENBQUNPLE1BQU0sQ0FBQ3pDLE1BQU0sQ0FBQzJDLE9BQU8sQ0FBQ0MsT0FBTyxDQUM3RGxFLE9BQU80RCxHQUFHO29CQUVaLElBQUlJLFNBQVMsR0FDWCxJQUFJLENBQUNiLFVBQVUsQ0FBQ0ssR0FBRyxDQUFDTyxNQUFNLENBQUN6QyxNQUFNLENBQUMyQyxPQUFPLENBQUNFLE1BQU0sQ0FBQ0gsT0FBTztnQkFDNUQ7Z0JBQ0EsSUFBSSxDQUFDOUIsSUFBSSxDQUFDLGlCQUFpQmxDO1lBQzdCO1lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ21ELFVBQVUsQ0FBQ0ssR0FBRyxFQUFFLElBQUksQ0FBQ1ksa0JBQWtCLENBQUNaO1lBQ2xELElBQUksQ0FBQ0wsVUFBVSxDQUFDSyxHQUFHLENBQUNLLE9BQU8sQ0FBQ1EsR0FBRyxDQUFDckUsT0FBTzRELEdBQUcsRUFBRTVEO1lBQzVDLElBQUksQ0FBQ2tDLElBQUksQ0FBQyxjQUFjbEMsUUFBUXNEO1lBQ2hDLE9BQU8sSUFBSSxDQUFDZ0IsVUFBVSxDQUFDdEUsUUFBUXdEO1FBQ2pDO1FBQ0EsSUFBSSxDQUFDSixHQUFHLENBQUNDLEVBQUUsQ0FBQyxTQUFTLENBQUN2QyxRQUFVLElBQUksQ0FBQ29CLElBQUksQ0FBQyxTQUFTcEI7SUFDckQ7SUFDQTs7Ozs7Ozs7RUFRQSxHQUNBeUQsU0FBU0MsSUFBSSxFQUFFQyxFQUFFLEVBQUVqQixLQUFLLEdBQUcsRUFBRTtRQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDTCxVQUFVLENBQUNLLEdBQUcsRUFBRSxJQUFJLENBQUNZLGtCQUFrQixDQUFDWjtRQUNsRCxJQUFJLENBQUNMLFVBQVUsQ0FBQ0ssR0FBRyxDQUFDa0IsV0FBVyxDQUFDRixLQUFLLEdBQUc7WUFDdENDO1lBQ0FFLFdBQVc7UUFDYjtRQUNBLE9BQU87WUFDTEEsV0FBVyxJQUFNLElBQUksQ0FBQ0Msb0JBQW9CLENBQUNKLE1BQU1oQjtZQUNqRHFCLFFBQVEsSUFBTSxJQUFJLENBQUNDLGlCQUFpQixDQUFDTixNQUFNaEI7UUFDN0M7SUFDRjtJQUNBOzs7Ozs7O0VBT0EsR0FDQXVCLFFBQVFOLEVBQUUsRUFBRWpCLEtBQUssR0FBRyxFQUFFO1FBQ3BCLElBQUksQ0FBQ2UsUUFBUSxDQUFDLGFBQWFFLElBQUlqQjtJQUNqQztJQUNBOzs7Ozs7RUFNQSxHQUNBb0IscUJBQXFCSixJQUFJLEVBQUVoQixLQUFLLEdBQUcsRUFBRTtRQUNuQyxJQUFJLENBQUNMLFVBQVUsQ0FBQ0ssR0FBRyxDQUFDa0IsV0FBVyxDQUFDRixLQUFLLENBQUNHLFNBQVMsR0FBRztJQUNwRDtJQUNBOzs7Ozs7RUFNQSxHQUNBRyxrQkFBa0JOLElBQUksRUFBRWhCLEtBQUssR0FBRyxFQUFFO1FBQ2hDLElBQUksQ0FBQ0wsVUFBVSxDQUFDSyxHQUFHLENBQUNrQixXQUFXLENBQUNGLEtBQUssQ0FBQ0csU0FBUyxHQUFHO0lBQ3BEO0lBQ0E7Ozs7OztFQU1BLEdBQ0FLLG9CQUFvQlIsSUFBSSxFQUFFaEIsS0FBSyxHQUFHLEVBQUU7UUFDbEMsSUFBSSxDQUFDTCxVQUFVLENBQUNLLEdBQUcsQ0FBQ08sTUFBTSxDQUFDUyxLQUFLLENBQUNHLFNBQVMsR0FBRztJQUMvQztJQUNBOzs7Ozs7RUFNQSxHQUNBTSxpQkFBaUJULElBQUksRUFBRWhCLEtBQUssR0FBRyxFQUFFO1FBQy9CLElBQUksQ0FBQ0wsVUFBVSxDQUFDSyxHQUFHLENBQUNPLE1BQU0sQ0FBQ1MsS0FBSyxDQUFDRyxTQUFTLEdBQUc7SUFDL0M7SUFDQTs7Ozs7O0VBTUEsR0FDQU8sZUFBZTFCLEVBQUUsRUFBRTtRQUNqQixNQUFNMkIsWUFBWSxJQUFJLENBQUNoQyxVQUFVLENBQUNLLEdBQUc7UUFDckMsSUFBSTJCLFdBQVc7WUFDYixPQUFPQSxVQUFVVCxXQUFXO1lBQzVCLE9BQU9TLFVBQVVwQixNQUFNO1lBQ3ZCLEtBQUssTUFBTS9ELFVBQVVtRixVQUFVdEIsT0FBTyxDQUFDdUIsTUFBTSxHQUFJcEYsT0FBT3lCLEtBQUs7WUFDN0QsT0FBTyxJQUFJLENBQUMwQixVQUFVLENBQUNLLEdBQUc7UUFDNUI7SUFDRjtJQUNBOzs7Ozs7O0VBT0EsR0FDQWxDLE1BQU1rRCxJQUFJLEVBQUVoQixLQUFLLEdBQUcsRUFBRTtRQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDTCxVQUFVLENBQUNLLEdBQUcsRUFBRSxJQUFJLENBQUNZLGtCQUFrQixDQUFDWjthQUM3QztZQUNILE1BQU1RLFFBQVEsSUFBSSxDQUFDYixVQUFVLENBQUNLLEdBQUcsQ0FBQ08sTUFBTSxDQUFDUyxLQUFLO1lBQzlDLElBQUlSLFVBQVUsS0FBSyxHQUNqQixNQUFNLElBQUl2RCxNQUFNLENBQUMseUJBQXlCLEVBQUUrQyxHQUFHLEVBQUVnQixLQUFLLENBQUM7UUFDM0Q7UUFDQSxJQUFJLENBQUNyQixVQUFVLENBQUNLLEdBQUcsQ0FBQ08sTUFBTSxDQUFDUyxLQUFLLEdBQUc7WUFDakNQLFNBQVMsRUFBRTtZQUNYVSxXQUFXO1FBQ2I7UUFDQSxJQUFJLENBQUN0QixFQUFFLENBQUNtQixNQUFNLENBQUMsR0FBR3JFO1lBQ2hCLElBQUlBLE9BQU9zQyxNQUFNLEtBQUssS0FBS3RDLE1BQU0sQ0FBQyxFQUFFLFlBQVl1QyxRQUM5Q3ZDLFNBQVNBLE1BQU0sQ0FBQyxFQUFFO1lBQ3BCLEtBQUssTUFBTXdELGFBQWEsSUFBSSxDQUFDUixVQUFVLENBQUNLLEdBQUcsQ0FBQ08sTUFBTSxDQUFDUyxLQUFLLENBQUNQLE9BQU8sQ0FBRTtnQkFDaEUsTUFBTWpFLFNBQVMsSUFBSSxDQUFDbUQsVUFBVSxDQUFDSyxHQUFHLENBQUNLLE9BQU8sQ0FBQ3dCLEdBQUcsQ0FBQzFCO2dCQUMvQyxJQUFJLENBQUMzRCxRQUFRO2dCQUNiQSxPQUFPYSxJQUFJLENBQ1QsSUFBSSxDQUFDckIsUUFBUSxDQUFDZixNQUFNLENBQUM7b0JBQ25COEQsY0FBY2lDO29CQUNkckU7Z0JBQ0Y7WUFFSjtRQUNGO1FBQ0EsT0FBTztZQUNMd0UsV0FBVyxJQUFNLElBQUksQ0FBQ0ssbUJBQW1CLENBQUNSLE1BQU1oQjtZQUNoRHFCLFFBQVEsSUFBTSxJQUFJLENBQUNJLGdCQUFnQixDQUFDVCxNQUFNaEI7UUFDNUM7SUFDRjtJQUNBOzs7Ozs7RUFNQSxHQUNBOEIsR0FBR2QsSUFBSSxFQUFFO1FBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQ3JCLFVBQVUsQ0FBQ3FCLEtBQUssRUFBRSxJQUFJLENBQUNKLGtCQUFrQixDQUFDSTtRQUNwRCxNQUFNZSxPQUFPLElBQUk7UUFDakIsT0FBTztZQUNMLG1DQUFtQztZQUNuQ2hCLFVBQVNpQixPQUFPLEVBQUVmLEVBQUU7Z0JBQ2xCLElBQUlnQixVQUFVaEQsTUFBTSxLQUFLLEdBQ3ZCLE1BQU0sSUFBSWhDLE1BQU07Z0JBQ2xCLElBQUksT0FBTytFLFlBQVksVUFDckIsTUFBTSxJQUFJL0UsTUFBTTtnQkFDbEIsSUFBSSxPQUFPZ0UsT0FBTyxZQUNoQixNQUFNLElBQUloRSxNQUFNO2dCQUNsQixPQUFPOEUsS0FBS2hCLFFBQVEsQ0FBQ2lCLFNBQVNmLElBQUlEO1lBQ3BDO1lBQ0EsZ0NBQWdDO1lBQ2hDbEQsT0FBTW9FLE9BQU87Z0JBQ1gsSUFBSUQsVUFBVWhELE1BQU0sS0FBSyxHQUN2QixNQUFNLElBQUloQyxNQUFNO2dCQUNsQixJQUFJLE9BQU9pRixZQUFZLFVBQ3JCLE1BQU0sSUFBSWpGLE1BQU07Z0JBQ2xCLE9BQU84RSxLQUFLakUsS0FBSyxDQUFDb0UsU0FBU2xCO1lBQzdCO1lBQ0Esb0NBQW9DO1lBQ3BDLElBQUltQixhQUFZO2dCQUNkLE9BQU9qRCxPQUFPQyxJQUFJLENBQUM0QyxLQUFLcEMsVUFBVSxDQUFDcUIsS0FBSyxDQUFDVCxNQUFNO1lBQ2pEO1lBQ0E7Ozs7Ozs7TUFPQSxHQUNBN0IsTUFBS1osS0FBSyxFQUFFLEdBQUduQixNQUFNO2dCQUNuQixNQUFNeUYsYUFBYTt1QkFBSUwsS0FBS3BDLFVBQVUsQ0FBQ3FCLEtBQUssQ0FBQ1gsT0FBTyxDQUFDbEIsSUFBSTtpQkFBRztnQkFDNUQsSUFBSyxJQUFJRyxJQUFJLEdBQUdsQyxJQUFJQSxLQUFLZ0YsVUFBVSxDQUFDOUMsRUFBRSxFQUFFLEVBQUVBLEVBQUc7b0JBQzNDeUMsS0FBS3BDLFVBQVUsQ0FBQ3FCLEtBQUssQ0FBQ1gsT0FBTyxDQUFDd0IsR0FBRyxDQUFDekUsSUFBSUMsSUFBSSxDQUN4QzBFLEtBQUsvRixRQUFRLENBQUNmLE1BQU0sQ0FBQzt3QkFDbkI4RCxjQUFjakI7d0JBQ2RuQixRQUFRQSxVQUFVLEVBQUU7b0JBQ3RCO2dCQUVKO1lBQ0Y7WUFDQTs7Ozs7O01BTUEsR0FDQSxJQUFJcUUsUUFBTztnQkFDVCxPQUFPQTtZQUNUO1lBQ0E7Ozs7O01BS0EsR0FDQXFCO2dCQUNFLE1BQU1ELGFBQWE7dUJBQUlMLEtBQUtwQyxVQUFVLENBQUNxQixLQUFLLENBQUNYLE9BQU8sQ0FBQ2xCLElBQUk7aUJBQUc7Z0JBQzVELE9BQU9pRCxXQUFXRSxNQUFNLENBQ3RCLENBQUNDLEtBQUtDLE9BQVU7d0JBQ2QsR0FBR0QsR0FBRzt3QkFDTixDQUFDQyxLQUFLLEVBQUVULEtBQUtwQyxVQUFVLENBQUNxQixLQUFLLENBQUNYLE9BQU8sQ0FBQ3dCLEdBQUcsQ0FBQ1c7b0JBQzVDLElBQ0EsQ0FBQztZQUVMO1lBQ0E7Ozs7O01BS0EsR0FDQW5DO2dCQUNFLE9BQU8wQixLQUFLcEMsVUFBVSxDQUFDcUIsS0FBSztZQUM5QjtRQUNGO0lBQ0Y7SUFDQTs7Ozs7O0VBTUEsR0FDQW1CLFVBQVVuQyxLQUFLLEdBQUcsRUFBRTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDTCxVQUFVLENBQUNLLEdBQUcsRUFBRSxPQUFPLEVBQUU7UUFDbkMsT0FBT2QsT0FBT0MsSUFBSSxDQUFDLElBQUksQ0FBQ1EsVUFBVSxDQUFDSyxHQUFHLENBQUNPLE1BQU07SUFDL0M7SUFDQTs7Ozs7OztFQU9BLEdBQ0FrQyxZQUFZdkUsSUFBSSxFQUFFaEIsT0FBTyxFQUFFaUIsSUFBSSxFQUFFO1FBQy9CLE9BQU87WUFDTEQ7WUFDQWhCO1lBQ0FpQixNQUFNQSxRQUFRO1FBQ2hCO0lBQ0Y7SUFDQTs7OztFQUlBLEdBQ0FGLFFBQVE7UUFDTixPQUFPLElBQUluQixRQUFRLENBQUNDLFNBQVNDO1lBQzNCLElBQUk7Z0JBQ0YsSUFBSSxDQUFDNEMsR0FBRyxDQUFDM0IsS0FBSztnQkFDZCxJQUFJLENBQUNTLElBQUksQ0FBQztnQkFDVjNCO1lBQ0YsRUFBRSxPQUFPTyxPQUFPO2dCQUNkTixPQUFPTTtZQUNUO1FBQ0Y7SUFDRjtJQUNBOzs7Ozs7RUFNQSxHQUNBd0QsV0FBV3RFLE1BQU0sRUFBRXdELEtBQUssR0FBRyxFQUFFO1FBQzNCeEQsT0FBT3FELEVBQUUsQ0FBQyxXQUFXLE9BQU8xQjtZQUMxQixNQUFNdUUsY0FBYyxDQUFDO1lBQ3JCLElBQUl2RSxnQkFBZ0JRLGFBQWE7Z0JBQy9CK0QsWUFBWUMsTUFBTSxHQUFHO2dCQUNyQnhFLE9BQU9TLE9BQU9DLElBQUksQ0FBQ1YsTUFBTVcsUUFBUTtZQUNuQztZQUNBLElBQUl0QyxPQUFPb0csVUFBVSxLQUFLLEdBQUc7WUFDN0IsSUFBSUM7WUFDSixJQUFJO2dCQUNGQSxhQUFhLElBQUksQ0FBQzdHLFFBQVEsQ0FBQ1gsTUFBTSxDQUFDOEM7WUFDcEMsRUFBRSxPQUFPYixPQUFPO2dCQUNkLE9BQU9kLE9BQU9hLElBQUksQ0FDaEIsSUFBSSxDQUFDckIsUUFBUSxDQUFDZixNQUFNLENBQUM7b0JBQ25Ca0MsU0FBUztvQkFDVEcsT0FBT21GLFlBQVksQ0FBQyxPQUFPbkYsTUFBTXdCLFFBQVE7b0JBQ3pDMUIsSUFBSTtnQkFDTixJQUNBc0Y7WUFFSjtZQUNBLElBQUlJLE1BQU1DLE9BQU8sQ0FBQ0YsYUFBYTtnQkFDN0IsSUFBSSxDQUFDQSxXQUFXNUQsTUFBTSxFQUNwQixPQUFPekMsT0FBT2EsSUFBSSxDQUNoQixJQUFJLENBQUNyQixRQUFRLENBQUNmLE1BQU0sQ0FBQztvQkFDbkJrQyxTQUFTO29CQUNURyxPQUFPbUYsWUFBWSxDQUFDLE9BQU87b0JBQzNCckYsSUFBSTtnQkFDTixJQUNBc0Y7Z0JBRUosTUFBTU0sWUFBWSxFQUFFO2dCQUNwQixLQUFLLE1BQU05RixXQUFXMkYsV0FBWTtvQkFDaEMsTUFBTUksWUFBWSxNQUFNLElBQUksQ0FBQ0MsVUFBVSxDQUFDaEcsU0FBU1YsT0FBTzRELEdBQUcsRUFBRUo7b0JBQzdELElBQUksQ0FBQ2lELFdBQVc7b0JBQ2hCRCxVQUFVM0QsSUFBSSxDQUFDNEQ7Z0JBQ2pCO2dCQUNBLElBQUksQ0FBQ0QsVUFBVS9ELE1BQU0sRUFBRTtnQkFDdkIsT0FBT3pDLE9BQU9hLElBQUksQ0FBQyxJQUFJLENBQUNyQixRQUFRLENBQUNmLE1BQU0sQ0FBQytILFlBQVlOO1lBQ3REO1lBQ0EsTUFBTVMsV0FBVyxNQUFNLElBQUksQ0FBQ0QsVUFBVSxDQUFDTCxZQUFZckcsT0FBTzRELEdBQUcsRUFBRUo7WUFDL0QsSUFBSSxDQUFDbUQsVUFBVTtZQUNmLE9BQU8zRyxPQUFPYSxJQUFJLENBQUMsSUFBSSxDQUFDckIsUUFBUSxDQUFDZixNQUFNLENBQUNrSSxXQUFXVDtRQUNyRDtJQUNGO0lBQ0E7Ozs7Ozs7RUFPQSxHQUNBLE1BQU1RLFdBQVdoRyxPQUFPLEVBQUVpRCxTQUFTLEVBQUVILEtBQUssR0FBRyxFQUFFO1FBQzdDLElBQUksT0FBTzlDLFlBQVksWUFBWUEsWUFBWSxNQUM3QyxPQUFPO1lBQ0xDLFNBQVM7WUFDVEcsT0FBT21GLFlBQVksQ0FBQztZQUNwQnJGLElBQUk7UUFDTjtRQUNGLElBQUlGLFFBQVFDLE9BQU8sS0FBSyxPQUN0QixPQUFPO1lBQ0xBLFNBQVM7WUFDVEcsT0FBT21GLFlBQVksQ0FBQyxPQUFPO1lBQzNCckYsSUFBSUYsUUFBUUUsRUFBRSxJQUFJO1FBQ3BCO1FBQ0YsSUFBSSxDQUFDRixRQUFRUixNQUFNLEVBQ2pCLE9BQU87WUFDTFMsU0FBUztZQUNURyxPQUFPbUYsWUFBWSxDQUFDLE9BQU87WUFDM0JyRixJQUFJRixRQUFRRSxFQUFFLElBQUk7UUFDcEI7UUFDRixJQUFJLE9BQU9GLFFBQVFSLE1BQU0sS0FBSyxVQUM1QixPQUFPO1lBQ0xTLFNBQVM7WUFDVEcsT0FBT21GLFlBQVksQ0FBQyxPQUFPO1lBQzNCckYsSUFBSUYsUUFBUUUsRUFBRSxJQUFJO1FBQ3BCO1FBQ0YsSUFBSUYsUUFBUVAsTUFBTSxJQUFJLE9BQU9PLFFBQVFQLE1BQU0sS0FBSyxVQUM5QyxPQUFPO1lBQ0xRLFNBQVM7WUFDVEcsT0FBT21GLFlBQVksQ0FBQztZQUNwQnJGLElBQUlGLFFBQVFFLEVBQUUsSUFBSTtRQUNwQjtRQUNGLElBQUlGLFFBQVFSLE1BQU0sS0FBSyxVQUFVO1lBQy9CLElBQUksQ0FBQ1EsUUFBUVAsTUFBTSxFQUNqQixPQUFPO2dCQUNMUSxTQUFTO2dCQUNURyxPQUFPbUYsWUFBWSxDQUFDO2dCQUNwQnJGLElBQUlGLFFBQVFFLEVBQUUsSUFBSTtZQUNwQjtZQUNGLE1BQU1nRyxVQUFVLENBQUM7WUFDakIsTUFBTUMsY0FBY25FLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUNRLFVBQVUsQ0FBQ0ssR0FBRyxDQUFDTyxNQUFNO1lBQzFELEtBQUssTUFBTVMsUUFBUTlELFFBQVFQLE1BQU0sQ0FBRTtnQkFDakMsTUFBTTZELFFBQVE2QyxZQUFZM0MsT0FBTyxDQUFDTTtnQkFDbEMsTUFBTVcsWUFBWSxJQUFJLENBQUNoQyxVQUFVLENBQUNLLEdBQUc7Z0JBQ3JDLElBQUlRLFVBQVUsQ0FBQyxHQUFHO29CQUNoQjRDLE9BQU8sQ0FBQ3BDLEtBQUssR0FBRztvQkFDaEI7Z0JBQ0Y7Z0JBQ0EsSUFBSVcsVUFBVXBCLE1BQU0sQ0FBQzhDLFdBQVcsQ0FBQzdDLE1BQU0sQ0FBQyxDQUFDVyxTQUFTLEtBQUssUUFBUVEsVUFBVXRCLE9BQU8sQ0FBQ3dCLEdBQUcsQ0FBQzFCLFVBQVUsQ0FBQyxpQkFBaUIsS0FBSyxPQUFPO29CQUMzSCxPQUFPO3dCQUNMaEQsU0FBUzt3QkFDVEcsT0FBT21GLFlBQVksQ0FBQzt3QkFDcEJyRixJQUFJRixRQUFRRSxFQUFFLElBQUk7b0JBQ3BCO2dCQUNGO2dCQUNBLE1BQU1rRyxlQUFlM0IsVUFBVXBCLE1BQU0sQ0FBQzhDLFdBQVcsQ0FBQzdDLE1BQU0sQ0FBQyxDQUFDQyxPQUFPLENBQUNDLE9BQU8sQ0FBQ1A7Z0JBQzFFLElBQUltRCxnQkFBZ0IsR0FBRztvQkFDckJGLE9BQU8sQ0FBQ3BDLEtBQUssR0FBRztvQkFDaEI7Z0JBQ0Y7Z0JBQ0FXLFVBQVVwQixNQUFNLENBQUM4QyxXQUFXLENBQUM3QyxNQUFNLENBQUMsQ0FBQ0MsT0FBTyxDQUFDcEIsSUFBSSxDQUFDYztnQkFDbERpRCxPQUFPLENBQUNwQyxLQUFLLEdBQUc7WUFDbEI7WUFDQSxPQUFPO2dCQUNMN0QsU0FBUztnQkFDVFksUUFBUXFGO2dCQUNSaEcsSUFBSUYsUUFBUUUsRUFBRSxJQUFJO1lBQ3BCO1FBQ0YsT0FBTyxJQUFJRixRQUFRUixNQUFNLEtBQUssV0FBVztZQUN2QyxJQUFJLENBQUNRLFFBQVFQLE1BQU0sRUFDakIsT0FBTztnQkFDTFEsU0FBUztnQkFDVEcsT0FBT21GLFlBQVksQ0FBQztnQkFDcEJyRixJQUFJRixRQUFRRSxFQUFFLElBQUk7WUFDcEI7WUFDRixNQUFNZ0csVUFBVSxDQUFDO1lBQ2pCLEtBQUssTUFBTXBDLFFBQVE5RCxRQUFRUCxNQUFNLENBQUU7Z0JBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUNnRCxVQUFVLENBQUNLLEdBQUcsQ0FBQ08sTUFBTSxDQUFDUyxLQUFLLEVBQUU7b0JBQ3JDb0MsT0FBTyxDQUFDcEMsS0FBSyxHQUFHO29CQUNoQjtnQkFDRjtnQkFDQSxNQUFNUixRQUFRLElBQUksQ0FBQ2IsVUFBVSxDQUFDSyxHQUFHLENBQUNPLE1BQU0sQ0FBQ1MsS0FBSyxDQUFDUCxPQUFPLENBQUNDLE9BQU8sQ0FBQ1A7Z0JBQy9ELElBQUlLLFVBQVUsQ0FBQyxHQUFHO29CQUNoQjRDLE9BQU8sQ0FBQ3BDLEtBQUssR0FBRztvQkFDaEI7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDckIsVUFBVSxDQUFDSyxHQUFHLENBQUNPLE1BQU0sQ0FBQ1MsS0FBSyxDQUFDUCxPQUFPLENBQUNFLE1BQU0sQ0FBQ0gsT0FBTztnQkFDdkQ0QyxPQUFPLENBQUNwQyxLQUFLLEdBQUc7WUFDbEI7WUFDQSxPQUFPO2dCQUNMN0QsU0FBUztnQkFDVFksUUFBUXFGO2dCQUNSaEcsSUFBSUYsUUFBUUUsRUFBRSxJQUFJO1lBQ3BCO1FBQ0YsT0FBTyxJQUFJRixRQUFRUixNQUFNLEtBQUssYUFBYTtZQUN6QyxJQUFJLENBQUNRLFFBQVFQLE1BQU0sRUFDakIsT0FBTztnQkFDTFEsU0FBUztnQkFDVEcsT0FBT21GLFlBQVksQ0FBQztnQkFDcEJyRixJQUFJRixRQUFRRSxFQUFFLElBQUk7WUFDcEI7UUFDSjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUN1QyxVQUFVLENBQUNLLEdBQUcsQ0FBQ2tCLFdBQVcsQ0FBQ2hFLFFBQVFSLE1BQU0sQ0FBQyxFQUFFO1lBQ3BELE9BQU87Z0JBQ0xTLFNBQVM7Z0JBQ1RHLE9BQU9tRixZQUFZLENBQUM7Z0JBQ3BCckYsSUFBSUYsUUFBUUUsRUFBRSxJQUFJO1lBQ3BCO1FBQ0Y7UUFDQSxJQUFJK0YsV0FBVztRQUNmLElBQUksSUFBSSxDQUFDeEQsVUFBVSxDQUFDSyxHQUFHLENBQUNrQixXQUFXLENBQUNoRSxRQUFRUixNQUFNLENBQUMsQ0FBQ3lFLFNBQVMsS0FBSyxRQUFRLElBQUksQ0FBQ3hCLFVBQVUsQ0FBQ0ssR0FBRyxDQUFDSyxPQUFPLENBQUN3QixHQUFHLENBQUMxQixVQUFVLENBQUMsaUJBQWlCLEtBQUssT0FBTztZQUNoSixPQUFPO2dCQUNMaEQsU0FBUztnQkFDVEcsT0FBT21GLFlBQVksQ0FBQztnQkFDcEJyRixJQUFJRixRQUFRRSxFQUFFLElBQUk7WUFDcEI7UUFDRjtRQUNBLElBQUk7WUFDRitGLFdBQVcsTUFBTSxJQUFJLENBQUN4RCxVQUFVLENBQUNLLEdBQUcsQ0FBQ2tCLFdBQVcsQ0FBQ2hFLFFBQVFSLE1BQU0sQ0FBQyxDQUFDdUUsRUFBRSxDQUNqRS9ELFFBQVFQLE1BQU0sRUFDZHdEO1FBRUosRUFBRSxPQUFPN0MsT0FBTztZQUNkLElBQUksQ0FBQ0osUUFBUUUsRUFBRSxFQUFFO1lBQ2pCLElBQUlFLGlCQUFpQkwsT0FDbkIsT0FBTztnQkFDTEUsU0FBUztnQkFDVEcsT0FBTztvQkFDTFksTUFBTSxDQUFDO29CQUNQaEIsU0FBU0ksTUFBTTBELElBQUk7b0JBQ25CN0MsTUFBTWIsTUFBTUosT0FBTztnQkFDckI7Z0JBQ0FFLElBQUlGLFFBQVFFLEVBQUU7WUFDaEI7WUFDRixPQUFPO2dCQUNMRCxTQUFTO2dCQUNURztnQkFDQUYsSUFBSUYsUUFBUUUsRUFBRTtZQUNoQjtRQUNGO1FBQ0EsSUFBSSxDQUFDRixRQUFRRSxFQUFFLEVBQUU7UUFDakIsSUFBSUYsUUFBUVIsTUFBTSxLQUFLLGVBQWV5RyxhQUFhLE1BQU07WUFDdkQsTUFBTUksSUFBSSxJQUFJLENBQUM1RCxVQUFVLENBQUNLLEdBQUcsQ0FBQ0ssT0FBTyxDQUFDd0IsR0FBRyxDQUFDMUI7WUFDMUNvRCxDQUFDLENBQUMsaUJBQWlCLEdBQUc7WUFDdEIsSUFBSSxDQUFDNUQsVUFBVSxDQUFDSyxHQUFHLENBQUNLLE9BQU8sQ0FBQ1EsR0FBRyxDQUFDVixXQUFXb0Q7UUFDN0M7UUFDQSxPQUFPO1lBQ0xwRyxTQUFTO1lBQ1RZLFFBQVFvRjtZQUNSL0YsSUFBSUYsUUFBUUUsRUFBRTtRQUNoQjtJQUNGO0lBQ0E7Ozs7OztFQU1BLEdBQ0F3RCxtQkFBbUJJLElBQUksRUFBRTtRQUN2QixJQUFJLENBQUNyQixVQUFVLENBQUNxQixLQUFLLEdBQUc7WUFDdEJFLGFBQWE7Z0JBQ1hzQyxlQUFlO29CQUNidkMsSUFBSSxJQUFNL0IsT0FBT0MsSUFBSSxDQUFDLElBQUksQ0FBQ1EsVUFBVSxDQUFDcUIsS0FBSyxDQUFDRSxXQUFXO29CQUN2REMsV0FBVztnQkFDYjtZQUNGO1lBQ0FkLFNBQVMsYUFBYSxHQUFHLElBQUlvRDtZQUM3QmxELFFBQVEsQ0FBQztRQUNYO0lBQ0Y7QUFDRjtBQUNBLElBQUltRCxhQUFhLGFBQWEsR0FBRyxJQUFJRCxJQUFJO0lBQ3ZDO1FBQUMsQ0FBQztRQUFNO0tBQXFCO0lBQzdCO1FBQUMsQ0FBQztRQUFPO0tBQWtCO0lBQzNCO1FBQUMsQ0FBQztRQUFPO0tBQW1CO0lBQzVCO1FBQUMsQ0FBQztRQUFPO0tBQWlCO0lBQzFCO1FBQUMsQ0FBQztRQUFPO0tBQWlCO0lBQzFCO1FBQUMsQ0FBQztRQUFPO0tBQW1CO0lBQzVCO1FBQUMsQ0FBQztRQUFPO0tBQW1CO0lBQzVCO1FBQUMsQ0FBQztRQUFPO0tBQWtCO0lBQzNCO1FBQUMsQ0FBQztRQUFPO0tBQWM7Q0FDeEI7QUFDRCxTQUFTaEIsWUFBWXZFLElBQUksRUFBRXlGLE9BQU87SUFDaEMsTUFBTXJHLFFBQVE7UUFDWlk7UUFDQWhCLFNBQVN3RyxXQUFXN0IsR0FBRyxDQUFDM0QsU0FBUztJQUNuQztJQUNBLElBQUl5RixTQUFTckcsS0FBSyxDQUFDLE9BQU8sR0FBR3FHO0lBQzdCLE9BQU9yRztBQUNUO0FBRUEsZUFBZTtBQUNmLElBQUlzRyxTQUFTLGNBQWNySTtJQUN6QkMsWUFBWVYsVUFBVSxxQkFBcUIsRUFBRSxFQUMzQ1ksY0FBYyxJQUFJLEVBQ2xCQyxZQUFZLElBQUksRUFDaEJDLHFCQUFxQixHQUFHLEVBQ3hCQyxpQkFBaUIsQ0FBQyxFQUNsQixHQUFHQyxjQUNKLEdBQUcsQ0FBQyxDQUFDLEVBQUVDLG1CQUFtQixDQUFFO1FBQzNCLEtBQUssQ0FDSGxCLFdBQ0FDLFNBQ0E7WUFDRVk7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQSxHQUFHQyxZQUFZO1FBQ2pCLEdBQ0FDO0lBRUo7QUFDRjtBQUVpRixDQUNqRiwrQkFBK0I7Q0FDL0Isa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hhcnB5Ly4vbm9kZV9tb2R1bGVzL3JwYy13ZWJzb2NrZXRzL2Rpc3QvaW5kZXgubWpzP2FkMTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFdlYlNvY2tldEltcGwsIHsgV2ViU29ja2V0U2VydmVyIH0gZnJvbSAnd3MnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgdXJsIGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IHYxIH0gZnJvbSAndXVpZCc7XG5cbi8vIHNyYy9saWIvY2xpZW50L3dlYnNvY2tldC50c1xuZnVuY3Rpb24gV2ViU29ja2V0KGFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBXZWJTb2NrZXRJbXBsKGFkZHJlc3MsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvbGliL3V0aWxzLnRzXG52YXIgRGVmYXVsdERhdGFQYWNrID0gY2xhc3Mge1xuICBlbmNvZGUodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIGRlY29kZSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9jbGllbnQudHNcbnZhciBDb21tb25DbGllbnQgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGFkZHJlc3M7XG4gIHJwY19pZDtcbiAgcXVldWU7XG4gIG9wdGlvbnM7XG4gIGF1dG9jb25uZWN0O1xuICByZWFkeTtcbiAgcmVjb25uZWN0O1xuICByZWNvbm5lY3RfdGltZXJfaWQ7XG4gIHJlY29ubmVjdF9pbnRlcnZhbDtcbiAgbWF4X3JlY29ubmVjdHM7XG4gIHJlc3Rfb3B0aW9ucztcbiAgY3VycmVudF9yZWNvbm5lY3RzO1xuICBnZW5lcmF0ZV9yZXF1ZXN0X2lkO1xuICBzb2NrZXQ7XG4gIHdlYlNvY2tldEZhY3Rvcnk7XG4gIGRhdGFQYWNrO1xuICAvKipcbiAgKiBJbnN0YW50aWF0ZSBhIENsaWVudCBjbGFzcy5cbiAgKiBAY29uc3RydWN0b3JcbiAgKiBAcGFyYW0ge3dlYlNvY2tldEZhY3Rvcnl9IHdlYlNvY2tldEZhY3RvcnkgLSBmYWN0b3J5IG1ldGhvZCBmb3IgV2ViU29ja2V0XG4gICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSB1cmwgdG8gYSB3ZWJzb2NrZXQgc2VydmVyXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB3cyBvcHRpb25zIG9iamVjdCB3aXRoIHJlY29ubmVjdCBwYXJhbWV0ZXJzXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZ2VuZXJhdGVfcmVxdWVzdF9pZCAtIGN1c3RvbSBnZW5lcmF0aW9uIHJlcXVlc3QgSWRcbiAgKiBAcGFyYW0ge0RhdGFQYWNrfSBkYXRhUGFjayAtIGRhdGEgcGFjayBjb250YWlucyBlbmNvZGVyIGFuZCBkZWNvZGVyXG4gICogQHJldHVybiB7Q29tbW9uQ2xpZW50fVxuICAqL1xuICBjb25zdHJ1Y3Rvcih3ZWJTb2NrZXRGYWN0b3J5LCBhZGRyZXNzID0gXCJ3czovL2xvY2FsaG9zdDo4MDgwXCIsIHtcbiAgICBhdXRvY29ubmVjdCA9IHRydWUsXG4gICAgcmVjb25uZWN0ID0gdHJ1ZSxcbiAgICByZWNvbm5lY3RfaW50ZXJ2YWwgPSAxZTMsXG4gICAgbWF4X3JlY29ubmVjdHMgPSA1LFxuICAgIC4uLnJlc3Rfb3B0aW9uc1xuICB9ID0ge30sIGdlbmVyYXRlX3JlcXVlc3RfaWQsIGRhdGFQYWNrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndlYlNvY2tldEZhY3RvcnkgPSB3ZWJTb2NrZXRGYWN0b3J5O1xuICAgIHRoaXMucXVldWUgPSB7fTtcbiAgICB0aGlzLnJwY19pZCA9IDA7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLmF1dG9jb25uZWN0ID0gYXV0b2Nvbm5lY3Q7XG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMucmVjb25uZWN0ID0gcmVjb25uZWN0O1xuICAgIHRoaXMucmVjb25uZWN0X3RpbWVyX2lkID0gdm9pZCAwO1xuICAgIHRoaXMucmVjb25uZWN0X2ludGVydmFsID0gcmVjb25uZWN0X2ludGVydmFsO1xuICAgIHRoaXMubWF4X3JlY29ubmVjdHMgPSBtYXhfcmVjb25uZWN0cztcbiAgICB0aGlzLnJlc3Rfb3B0aW9ucyA9IHJlc3Rfb3B0aW9ucztcbiAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA9IDA7XG4gICAgdGhpcy5nZW5lcmF0ZV9yZXF1ZXN0X2lkID0gZ2VuZXJhdGVfcmVxdWVzdF9pZCB8fCAoKCkgPT4gKyt0aGlzLnJwY19pZCk7XG4gICAgaWYgKCFkYXRhUGFjaykgdGhpcy5kYXRhUGFjayA9IG5ldyBEZWZhdWx0RGF0YVBhY2soKTtcbiAgICBlbHNlIHRoaXMuZGF0YVBhY2sgPSBkYXRhUGFjaztcbiAgICBpZiAodGhpcy5hdXRvY29ubmVjdClcbiAgICAgIHRoaXMuX2Nvbm5lY3QodGhpcy5hZGRyZXNzLCB7XG4gICAgICAgIGF1dG9jb25uZWN0OiB0aGlzLmF1dG9jb25uZWN0LFxuICAgICAgICByZWNvbm5lY3Q6IHRoaXMucmVjb25uZWN0LFxuICAgICAgICByZWNvbm5lY3RfaW50ZXJ2YWw6IHRoaXMucmVjb25uZWN0X2ludGVydmFsLFxuICAgICAgICBtYXhfcmVjb25uZWN0czogdGhpcy5tYXhfcmVjb25uZWN0cyxcbiAgICAgICAgLi4udGhpcy5yZXN0X29wdGlvbnNcbiAgICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIENvbm5lY3RzIHRvIGEgZGVmaW5lZCBzZXJ2ZXIgaWYgbm90IGNvbm5lY3RlZCBhbHJlYWR5LlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIGNvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0KSByZXR1cm47XG4gICAgdGhpcy5fY29ubmVjdCh0aGlzLmFkZHJlc3MsIHtcbiAgICAgIGF1dG9jb25uZWN0OiB0aGlzLmF1dG9jb25uZWN0LFxuICAgICAgcmVjb25uZWN0OiB0aGlzLnJlY29ubmVjdCxcbiAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWwsXG4gICAgICBtYXhfcmVjb25uZWN0czogdGhpcy5tYXhfcmVjb25uZWN0cyxcbiAgICAgIC4uLnRoaXMucmVzdF9vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQ2FsbHMgYSByZWdpc3RlcmVkIFJQQyBtZXRob2Qgb24gc2VydmVyLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIC0gUlBDIG1ldGhvZCBuYW1lXG4gICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHBhcmFtcyAtIG9wdGlvbmFsIG1ldGhvZCBwYXJhbWV0ZXJzXG4gICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgLSBSUEMgcmVwbHkgdGltZW91dCB2YWx1ZVxuICAqIEBwYXJhbSB7T2JqZWN0fSB3c19vcHRzIC0gb3B0aW9ucyBwYXNzZWQgdG8gd3NcbiAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICBjYWxsKG1ldGhvZCwgcGFyYW1zLCB0aW1lb3V0LCB3c19vcHRzKSB7XG4gICAgaWYgKCF3c19vcHRzICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0aW1lb3V0KSB7XG4gICAgICB3c19vcHRzID0gdGltZW91dDtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnJlYWR5KSByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcInNvY2tldCBub3QgcmVhZHlcIikpO1xuICAgICAgY29uc3QgcnBjX2lkID0gdGhpcy5nZW5lcmF0ZV9yZXF1ZXN0X2lkKG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMgfHwgdm9pZCAwLFxuICAgICAgICBpZDogcnBjX2lkXG4gICAgICB9O1xuICAgICAgdGhpcy5zb2NrZXQuc2VuZCh0aGlzLmRhdGFQYWNrLmVuY29kZShtZXNzYWdlKSwgd3Nfb3B0cywgKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIHRoaXMucXVldWVbcnBjX2lkXSA9IHsgcHJvbWlzZTogW3Jlc29sdmUsIHJlamVjdF0gfTtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlW3JwY19pZF0udGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucXVldWVbcnBjX2lkXTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJyZXBseSB0aW1lb3V0XCIpKTtcbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogTG9naW5zIHdpdGggdGhlIG90aGVyIHNpZGUgb2YgdGhlIGNvbm5lY3Rpb24uXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBMb2dpbiBjcmVkZW50aWFscyBvYmplY3RcbiAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICBhc3luYyBsb2dpbihwYXJhbXMpIHtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5jYWxsKFwicnBjLmxvZ2luXCIsIHBhcmFtcyk7XG4gICAgaWYgKCFyZXNwKSB0aHJvdyBuZXcgRXJyb3IoXCJhdXRoZW50aWNhdGlvbiBmYWlsZWRcIik7XG4gICAgcmV0dXJuIHJlc3A7XG4gIH1cbiAgLyoqXG4gICogRmV0Y2hlcyBhIGxpc3Qgb2YgY2xpZW50J3MgbWV0aG9kcyByZWdpc3RlcmVkIG9uIHNlcnZlci5cbiAgKiBAbWV0aG9kXG4gICogQHJldHVybiB7QXJyYXl9XG4gICovXG4gIGFzeW5jIGxpc3RNZXRob2RzKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNhbGwoXCJfX2xpc3RNZXRob2RzXCIpO1xuICB9XG4gIC8qKlxuICAqIFNlbmRzIGEgSlNPTi1SUEMgMi4wIG5vdGlmaWNhdGlvbiB0byBzZXJ2ZXIuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgLSBSUEMgbWV0aG9kIG5hbWVcbiAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gb3B0aW9uYWwgbWV0aG9kIHBhcmFtZXRlcnNcbiAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICBub3RpZnkobWV0aG9kLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnJlYWR5KSByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcInNvY2tldCBub3QgcmVhZHlcIikpO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH07XG4gICAgICB0aGlzLnNvY2tldC5zZW5kKHRoaXMuZGF0YVBhY2suZW5jb2RlKG1lc3NhZ2UpLCAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogU3Vic2NyaWJlcyBmb3IgYSBkZWZpbmVkIGV2ZW50LlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gZXZlbnQgLSBldmVudCBuYW1lXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqIEB0aHJvd3Mge0Vycm9yfVxuICAqL1xuICBhc3luYyBzdWJzY3JpYmUoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKSBldmVudCA9IFtldmVudF07XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jYWxsKFwicnBjLm9uXCIsIGV2ZW50KTtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiICYmIHJlc3VsdFtldmVudF0gIT09IFwib2tcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJGYWlsZWQgc3Vic2NyaWJpbmcgdG8gYW4gZXZlbnQgJ1wiICsgZXZlbnQgKyBcIicgd2l0aDogXCIgKyByZXN1bHRbZXZlbnRdXG4gICAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICogVW5zdWJzY3JpYmVzIGZyb20gYSBkZWZpbmVkIGV2ZW50LlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gZXZlbnQgLSBldmVudCBuYW1lXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqIEB0aHJvd3Mge0Vycm9yfVxuICAqL1xuICBhc3luYyB1bnN1YnNjcmliZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpIGV2ZW50ID0gW2V2ZW50XTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNhbGwoXCJycGMub2ZmXCIsIGV2ZW50KTtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiICYmIHJlc3VsdFtldmVudF0gIT09IFwib2tcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB1bnN1YnNjcmliaW5nIGZyb20gYW4gZXZlbnQgd2l0aDogXCIgKyByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICogQ2xvc2VzIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gZ3JhY2VmdWxseS5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgLSBzb2NrZXQgY2xvc2UgY29kZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIC0gb3B0aW9uYWwgZGF0YSB0byBiZSBzZW50IGJlZm9yZSBjbG9zaW5nXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBjbG9zZShjb2RlLCBkYXRhKSB7XG4gICAgdGhpcy5zb2NrZXQuY2xvc2UoY29kZSB8fCAxZTMsIGRhdGEpO1xuICB9XG4gIC8qKlxuICAqIEVuYWJsZSAvIGRpc2FibGUgYXV0b21hdGljIHJlY29ubmVjdGlvbi5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtCb29sZWFufSByZWNvbm5lY3QgLSBlbmFibGUgLyBkaXNhYmxlIHJlY29ubmVjdGlvblxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgc2V0QXV0b1JlY29ubmVjdChyZWNvbm5lY3QpIHtcbiAgICB0aGlzLnJlY29ubmVjdCA9IHJlY29ubmVjdDtcbiAgfVxuICAvKipcbiAgKiBTZXQgdGhlIGludGVydmFsIGJldHdlZW4gcmVjb25uZWN0aW9uIGF0dGVtcHRzLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge051bWJlcn0gaW50ZXJ2YWwgLSByZWNvbm5lY3Rpb24gaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBzZXRSZWNvbm5lY3RJbnRlcnZhbChpbnRlcnZhbCkge1xuICAgIHRoaXMucmVjb25uZWN0X2ludGVydmFsID0gaW50ZXJ2YWw7XG4gIH1cbiAgLyoqXG4gICogU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhfcmVjb25uZWN0cyAtIG1heGltdW0gcmVjb25uZWN0aW9uIGF0dGVtcHRzXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBzZXRNYXhSZWNvbm5lY3RzKG1heF9yZWNvbm5lY3RzKSB7XG4gICAgdGhpcy5tYXhfcmVjb25uZWN0cyA9IG1heF9yZWNvbm5lY3RzO1xuICB9XG4gIC8qKlxuICAqIENvbm5lY3Rpb24vTWVzc2FnZSBoYW5kbGVyLlxuICAqIEBtZXRob2RcbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIC0gV2ViU29ja2V0IEFQSSBhZGRyZXNzXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB3cyBvcHRpb25zIG9iamVjdFxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgX2Nvbm5lY3QoYWRkcmVzcywgb3B0aW9ucykge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdF90aW1lcl9pZCk7XG4gICAgdGhpcy5zb2NrZXQgPSB0aGlzLndlYlNvY2tldEZhY3RvcnkoYWRkcmVzcywgb3B0aW9ucyk7XG4gICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoXCJvcGVuXCIpO1xuICAgICAgdGhpcy5jdXJyZW50X3JlY29ubmVjdHMgPSAwO1xuICAgIH0pO1xuICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsICh7IGRhdGE6IG1lc3NhZ2UgfSkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLnRvU3RyaW5nKCk7XG4gICAgICB0cnkge1xuICAgICAgICBtZXNzYWdlID0gdGhpcy5kYXRhUGFjay5kZWNvZGUobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5ub3RpZmljYXRpb24gJiYgdGhpcy5saXN0ZW5lcnMobWVzc2FnZS5ub3RpZmljYXRpb24pLmxlbmd0aCkge1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKG1lc3NhZ2UucGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChtZXNzYWdlLm5vdGlmaWNhdGlvbik7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbbWVzc2FnZS5ub3RpZmljYXRpb25dO1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMuY29uc3RydWN0b3IgPT09IE9iamVjdCkgYXJncy5wdXNoKG1lc3NhZ2UucGFyYW1zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5wYXJhbXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBhcmdzLnB1c2gobWVzc2FnZS5wYXJhbXNbaV0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5xdWV1ZVttZXNzYWdlLmlkXSkge1xuICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQobWVzc2FnZS5tZXRob2QsIG1lc3NhZ2U/LnBhcmFtcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKFwiZXJyb3JcIiBpbiBtZXNzYWdlID09PSBcInJlc3VsdFwiIGluIG1lc3NhZ2UpXG4gICAgICAgIHRoaXMucXVldWVbbWVzc2FnZS5pZF0ucHJvbWlzZVsxXShcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnU2VydmVyIHJlc3BvbnNlIG1hbGZvcm1lZC4gUmVzcG9uc2UgbXVzdCBpbmNsdWRlIGVpdGhlciBcInJlc3VsdFwiIG9yIFwiZXJyb3JcIiwgYnV0IG5vdCBib3RoLidcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICBpZiAodGhpcy5xdWV1ZVttZXNzYWdlLmlkXS50aW1lb3V0KVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5xdWV1ZVttZXNzYWdlLmlkXS50aW1lb3V0KTtcbiAgICAgIGlmIChtZXNzYWdlLmVycm9yKSB0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnByb21pc2VbMV0obWVzc2FnZS5lcnJvcik7XG4gICAgICBlbHNlIHRoaXMucXVldWVbbWVzc2FnZS5pZF0ucHJvbWlzZVswXShtZXNzYWdlLnJlc3VsdCk7XG4gICAgICBkZWxldGUgdGhpcy5xdWV1ZVttZXNzYWdlLmlkXTtcbiAgICB9KTtcbiAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcikpO1xuICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCAoeyBjb2RlLCByZWFzb24gfSkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVhZHkpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5lbWl0KFwiY2xvc2VcIiwgY29kZSwgcmVhc29uKSwgMCk7XG4gICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLnNvY2tldCA9IHZvaWQgMDtcbiAgICAgIGlmIChjb2RlID09PSAxZTMpIHJldHVybjtcbiAgICAgIHRoaXMuY3VycmVudF9yZWNvbm5lY3RzKys7XG4gICAgICBpZiAodGhpcy5yZWNvbm5lY3QgJiYgKHRoaXMubWF4X3JlY29ubmVjdHMgPiB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyB8fCB0aGlzLm1heF9yZWNvbm5lY3RzID09PSAwKSlcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RfdGltZXJfaWQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICgpID0+IHRoaXMuX2Nvbm5lY3QoYWRkcmVzcywgb3B0aW9ucyksXG4gICAgICAgICAgdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWxcbiAgICAgICAgKTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBTZXJ2ZXIgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIG5hbWVzcGFjZXM7XG4gIGRhdGFQYWNrO1xuICB3c3M7XG4gIC8qKlxuICAqIEluc3RhbnRpYXRlIGEgU2VydmVyIGNsYXNzLlxuICAqIEBjb25zdHJ1Y3RvclxuICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gd3MgY29uc3RydWN0b3IncyBwYXJhbWV0ZXJzIHdpdGggcnBjXG4gICogQHBhcmFtIHtEYXRhUGFja30gZGF0YVBhY2sgLSBkYXRhIHBhY2sgY29udGFpbnMgZW5jb2RlciBhbmQgZGVjb2RlclxuICAqIEByZXR1cm4ge1NlcnZlcn0gLSByZXR1cm5zIGEgbmV3IFNlcnZlciBpbnN0YW5jZVxuICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBkYXRhUGFjaykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uYW1lc3BhY2VzID0ge307XG4gICAgaWYgKCFkYXRhUGFjaykgdGhpcy5kYXRhUGFjayA9IG5ldyBEZWZhdWx0RGF0YVBhY2soKTtcbiAgICBlbHNlIHRoaXMuZGF0YVBhY2sgPSBkYXRhUGFjaztcbiAgICB0aGlzLndzcyA9IG5ldyBXZWJTb2NrZXRTZXJ2ZXIob3B0aW9ucyk7XG4gICAgdGhpcy53c3Mub24oXCJsaXN0ZW5pbmdcIiwgKCkgPT4gdGhpcy5lbWl0KFwibGlzdGVuaW5nXCIpKTtcbiAgICB0aGlzLndzcy5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCwgcmVxdWVzdCkgPT4ge1xuICAgICAgY29uc3QgdSA9IHVybC5wYXJzZShyZXF1ZXN0LnVybCwgdHJ1ZSk7XG4gICAgICBjb25zdCBucyA9IHUucGF0aG5hbWU7XG4gICAgICBpZiAodS5xdWVyeS5zb2NrZXRfaWQpIHNvY2tldC5faWQgPSB1LnF1ZXJ5LnNvY2tldF9pZDtcbiAgICAgIGVsc2Ugc29ja2V0Ll9pZCA9IHYxKCk7XG4gICAgICBzb2NrZXRbXCJfYXV0aGVudGljYXRlZFwiXSA9IGZhbHNlO1xuICAgICAgc29ja2V0Lm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB0aGlzLmVtaXQoXCJzb2NrZXQtZXJyb3JcIiwgc29ja2V0LCBlcnJvcikpO1xuICAgICAgc29ja2V0Lm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmNsaWVudHMuZGVsZXRlKHNvY2tldC5faWQpO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzKSkge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbZXZlbnRdLnNvY2tldHMuaW5kZXhPZihcbiAgICAgICAgICAgIHNvY2tldC5faWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpbmRleCA+PSAwKVxuICAgICAgICAgICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbZXZlbnRdLnNvY2tldHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0aW9uXCIsIHNvY2tldCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXSkgdGhpcy5fZ2VuZXJhdGVOYW1lc3BhY2UobnMpO1xuICAgICAgdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLnNldChzb2NrZXQuX2lkLCBzb2NrZXQpO1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvblwiLCBzb2NrZXQsIHJlcXVlc3QpO1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVJQQyhzb2NrZXQsIG5zKTtcbiAgICB9KTtcbiAgICB0aGlzLndzcy5vbihcImVycm9yXCIsIChlcnJvcikgPT4gdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpKTtcbiAgfVxuICAvKipcbiAgKiBSZWdpc3RlcnMgYW4gUlBDIG1ldGhvZC5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBtZXRob2QgbmFtZVxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gYSBjYWxsZWUgZnVuY3Rpb25cbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgKiBAcmV0dXJuIHtPYmplY3R9IC0gcmV0dXJucyBhbiBJTWV0aG9kIG9iamVjdFxuICAqL1xuICByZWdpc3RlcihuYW1lLCBmbiwgbnMgPSBcIi9cIikge1xuICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXSkgdGhpcy5fZ2VuZXJhdGVOYW1lc3BhY2UobnMpO1xuICAgIHRoaXMubmFtZXNwYWNlc1tuc10ucnBjX21ldGhvZHNbbmFtZV0gPSB7XG4gICAgICBmbixcbiAgICAgIHByb3RlY3RlZDogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBwcm90ZWN0ZWQ6ICgpID0+IHRoaXMuX21ha2VQcm90ZWN0ZWRNZXRob2QobmFtZSwgbnMpLFxuICAgICAgcHVibGljOiAoKSA9PiB0aGlzLl9tYWtlUHVibGljTWV0aG9kKG5hbWUsIG5zKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICogU2V0cyBhbiBhdXRoIG1ldGhvZC5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBhbiBhcmJpdHJhcnkgYXV0aCBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIHNldEF1dGgoZm4sIG5zID0gXCIvXCIpIHtcbiAgICB0aGlzLnJlZ2lzdGVyKFwicnBjLmxvZ2luXCIsIGZuLCBucyk7XG4gIH1cbiAgLyoqXG4gICogTWFya3MgYW4gUlBDIG1ldGhvZCBhcyBwcm90ZWN0ZWQuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbWV0aG9kIG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgX21ha2VQcm90ZWN0ZWRNZXRob2QobmFtZSwgbnMgPSBcIi9cIikge1xuICAgIHRoaXMubmFtZXNwYWNlc1tuc10ucnBjX21ldGhvZHNbbmFtZV0ucHJvdGVjdGVkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgKiBNYXJrcyBhbiBSUEMgbWV0aG9kIGFzIHB1YmxpYy5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBtZXRob2QgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfbWFrZVB1YmxpY01ldGhvZChuYW1lLCBucyA9IFwiL1wiKSB7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1tuYW1lXS5wcm90ZWN0ZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgKiBNYXJrcyBhbiBldmVudCBhcyBwcm90ZWN0ZWQuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gZXZlbnQgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfbWFrZVByb3RlY3RlZEV2ZW50KG5hbWUsIG5zID0gXCIvXCIpIHtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXS5wcm90ZWN0ZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAqIE1hcmtzIGFuIGV2ZW50IGFzIHB1YmxpYy5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBldmVudCBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9tYWtlUHVibGljRXZlbnQobmFtZSwgbnMgPSBcIi9cIikge1xuICAgIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdLnByb3RlY3RlZCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIFJlbW92ZXMgYSBuYW1lc3BhY2UgYW5kIGNsb3NlcyBhbGwgY29ubmVjdGlvbnNcbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBjbG9zZU5hbWVzcGFjZShucykge1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IHRoaXMubmFtZXNwYWNlc1tuc107XG4gICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgZGVsZXRlIG5hbWVzcGFjZS5ycGNfbWV0aG9kcztcbiAgICAgIGRlbGV0ZSBuYW1lc3BhY2UuZXZlbnRzO1xuICAgICAgZm9yIChjb25zdCBzb2NrZXQgb2YgbmFtZXNwYWNlLmNsaWVudHMudmFsdWVzKCkpIHNvY2tldC5jbG9zZSgpO1xuICAgICAgZGVsZXRlIHRoaXMubmFtZXNwYWNlc1tuc107XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIENyZWF0ZXMgYSBuZXcgZXZlbnQgdGhhdCBjYW4gYmUgZW1pdHRlZCB0byBjbGllbnRzLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGV2ZW50IG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgKiBAcmV0dXJuIHtPYmplY3R9IC0gcmV0dXJucyBhbiBJRXZlbnQgb2JqZWN0XG4gICovXG4gIGV2ZW50KG5hbWUsIG5zID0gXCIvXCIpIHtcbiAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10pIHRoaXMuX2dlbmVyYXRlTmFtZXNwYWNlKG5zKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV07XG4gICAgICBpZiAoaW5kZXggIT09IHZvaWQgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbHJlYWR5IHJlZ2lzdGVyZWQgZXZlbnQgJHtuc30ke25hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdID0ge1xuICAgICAgc29ja2V0czogW10sXG4gICAgICBwcm90ZWN0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLm9uKG5hbWUsICguLi5wYXJhbXMpID0+IHtcbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxICYmIHBhcmFtc1swXSBpbnN0YW5jZW9mIE9iamVjdClcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zWzBdO1xuICAgICAgZm9yIChjb25zdCBzb2NrZXRfaWQgb2YgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0uc29ja2V0cykge1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm5hbWVzcGFjZXNbbnNdLmNsaWVudHMuZ2V0KHNvY2tldF9pZCk7XG4gICAgICAgIGlmICghc29ja2V0KSBjb250aW51ZTtcbiAgICAgICAgc29ja2V0LnNlbmQoXG4gICAgICAgICAgdGhpcy5kYXRhUGFjay5lbmNvZGUoe1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uOiBuYW1lLFxuICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvdGVjdGVkOiAoKSA9PiB0aGlzLl9tYWtlUHJvdGVjdGVkRXZlbnQobmFtZSwgbnMpLFxuICAgICAgcHVibGljOiAoKSA9PiB0aGlzLl9tYWtlUHVibGljRXZlbnQobmFtZSwgbnMpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBSZXR1cm5zIGEgcmVxdWVzdGVkIG5hbWVzcGFjZSBvYmplY3RcbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgKiBAcmV0dXJuIHtPYmplY3R9IC0gbmFtZXNwYWNlIG9iamVjdFxuICAqL1xuICBvZihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLm5hbWVzcGFjZXNbbmFtZV0pIHRoaXMuX2dlbmVyYXRlTmFtZXNwYWNlKG5hbWUpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBzZWxmLnJlZ2lzdGVyIGNvbnZlbmllbmNlIG1ldGhvZFxuICAgICAgcmVnaXN0ZXIoZm5fbmFtZSwgZm4pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibXVzdCBwcm92aWRlIGV4YWN0bHkgdHdvIGFyZ3VtZW50c1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbl9uYW1lICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImhhbmRsZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gc2VsZi5yZWdpc3Rlcihmbl9uYW1lLCBmbiwgbmFtZSk7XG4gICAgICB9LFxuICAgICAgLy8gc2VsZi5ldmVudCBjb252ZW5pZW5jZSBtZXRob2RcbiAgICAgIGV2ZW50KGV2X25hbWUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibXVzdCBwcm92aWRlIGV4YWN0bHkgb25lIGFyZ3VtZW50XCIpO1xuICAgICAgICBpZiAodHlwZW9mIGV2X25hbWUgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICByZXR1cm4gc2VsZi5ldmVudChldl9uYW1lLCBuYW1lKTtcbiAgICAgIH0sXG4gICAgICAvLyBzZWxmLmV2ZW50TGlzdCBjb252ZW5pZW5jZSBtZXRob2RcbiAgICAgIGdldCBldmVudExpc3QoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzZWxmLm5hbWVzcGFjZXNbbmFtZV0uZXZlbnRzKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICogRW1pdHMgYSBzcGVjaWZpZWQgZXZlbnQgdG8gdGhpcyBuYW1lc3BhY2UuXG4gICAgICAqIEBpbm5lclxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAtIGV2ZW50IG5hbWVcbiAgICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIC0gZXZlbnQgcGFyYW1ldGVyc1xuICAgICAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICAgICAqL1xuICAgICAgZW1pdChldmVudCwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldF9pZHMgPSBbLi4uc2VsZi5uYW1lc3BhY2VzW25hbWVdLmNsaWVudHMua2V5cygpXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlkOyBpZCA9IHNvY2tldF9pZHNbaV07ICsraSkge1xuICAgICAgICAgIHNlbGYubmFtZXNwYWNlc1tuYW1lXS5jbGllbnRzLmdldChpZCkuc2VuZChcbiAgICAgICAgICAgIHNlbGYuZGF0YVBhY2suZW5jb2RlKHtcbiAgICAgICAgICAgICAgbm90aWZpY2F0aW9uOiBldmVudCxcbiAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMgfHwgW11cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgKiBSZXR1cm5zIGEgbmFtZSBvZiB0aGlzIG5hbWVzcGFjZS5cbiAgICAgICogQGlubmVyXG4gICAgICAqIEBtZXRob2RcbiAgICAgICogQGtpbmQgY29uc3RhbnRcbiAgICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAgKi9cbiAgICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICogUmV0dXJucyBhIGhhc2ggb2Ygd2Vic29ja2V0IG9iamVjdHMgY29ubmVjdGVkIHRvIHRoaXMgbmFtZXNwYWNlLlxuICAgICAgKiBAaW5uZXJcbiAgICAgICogQG1ldGhvZFxuICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAqL1xuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBjb25zdCBzb2NrZXRfaWRzID0gWy4uLnNlbGYubmFtZXNwYWNlc1tuYW1lXS5jbGllbnRzLmtleXMoKV07XG4gICAgICAgIHJldHVybiBzb2NrZXRfaWRzLnJlZHVjZShcbiAgICAgICAgICAoYWNjLCBjdXJyKSA9PiAoe1xuICAgICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgICAgW2N1cnJdOiBzZWxmLm5hbWVzcGFjZXNbbmFtZV0uY2xpZW50cy5nZXQoY3VycilcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7fVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBjbGllbnQgdW5pcXVlIGlkZW50aWZpZXJzIGNvbm5lY3RlZCB0byB0aGlzIG5hbWVzcGFjZS5cbiAgICAgICogQGlubmVyXG4gICAgICAqIEBtZXRob2RcbiAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAqL1xuICAgICAgY2xpZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubmFtZXNwYWNlc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAqIExpc3RzIGFsbCBjcmVhdGVkIGV2ZW50cyBpbiBhIGdpdmVuIG5hbWVzcGFjZS4gRGVmYXVsdHMgdG8gXCIvXCIuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZXMgaWRlbnRpZmllclxuICAqIEByZWFkb25seVxuICAqIEByZXR1cm4ge0FycmF5fSAtIHJldHVybnMgYSBsaXN0IG9mIGNyZWF0ZWQgZXZlbnRzXG4gICovXG4gIGV2ZW50TGlzdChucyA9IFwiL1wiKSB7XG4gICAgaWYgKCF0aGlzLm5hbWVzcGFjZXNbbnNdKSByZXR1cm4gW107XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzKTtcbiAgfVxuICAvKipcbiAgKiBDcmVhdGVzIGEgSlNPTi1SUEMgMi4wIGNvbXBsaWFudCBlcnJvclxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge051bWJlcn0gY29kZSAtIGluZGljYXRlcyB0aGUgZXJyb3IgdHlwZSB0aGF0IG9jY3VycmVkXG4gICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSBwcm92aWRlcyBhIHNob3J0IGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvclxuICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGF0YSAtIGRldGFpbHMgY29udGFpbmluZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvclxuICAqIEByZXR1cm4ge09iamVjdH1cbiAgKi9cbiAgY3JlYXRlRXJyb3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2RlLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGRhdGE6IGRhdGEgfHwgbnVsbFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICogQ2xvc2VzIHRoZSBzZXJ2ZXIgYW5kIHRlcm1pbmF0ZXMgYWxsIGNsaWVudHMuXG4gICogQG1ldGhvZFxuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLndzcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBIYW5kbGVzIGFsbCBXZWJTb2NrZXQgSlNPTiBSUEMgMi4wIHJlcXVlc3RzLlxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtPYmplY3R9IHNvY2tldCAtIHdzIHNvY2tldCBpbnN0YW5jZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZXMgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgX2hhbmRsZVJQQyhzb2NrZXQsIG5zID0gXCIvXCIpIHtcbiAgICBzb2NrZXQub24oXCJtZXNzYWdlXCIsIGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICBjb25zdCBtc2dfb3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBtc2dfb3B0aW9ucy5iaW5hcnkgPSB0cnVlO1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0gMSkgcmV0dXJuO1xuICAgICAgbGV0IHBhcnNlZERhdGE7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWREYXRhID0gdGhpcy5kYXRhUGFjay5kZWNvZGUoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gc29ja2V0LnNlbmQoXG4gICAgICAgICAgdGhpcy5kYXRhUGFjay5lbmNvZGUoe1xuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI3MDAsIGVycm9yLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgaWQ6IG51bGxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtc2dfb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkRGF0YSkpIHtcbiAgICAgICAgaWYgKCFwYXJzZWREYXRhLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gc29ja2V0LnNlbmQoXG4gICAgICAgICAgICB0aGlzLmRhdGFQYWNrLmVuY29kZSh7XG4gICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDAsIFwiSW52YWxpZCBhcnJheVwiKSxcbiAgICAgICAgICAgICAgaWQ6IG51bGxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbXNnX29wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICBjb25zdCByZXNwb25zZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHBhcnNlZERhdGEpIHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZTIgPSBhd2FpdCB0aGlzLl9ydW5NZXRob2QobWVzc2FnZSwgc29ja2V0Ll9pZCwgbnMpO1xuICAgICAgICAgIGlmICghcmVzcG9uc2UyKSBjb250aW51ZTtcbiAgICAgICAgICByZXNwb25zZXMucHVzaChyZXNwb25zZTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2VzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gc29ja2V0LnNlbmQodGhpcy5kYXRhUGFjay5lbmNvZGUocmVzcG9uc2VzKSwgbXNnX29wdGlvbnMpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9ydW5NZXRob2QocGFyc2VkRGF0YSwgc29ja2V0Ll9pZCwgbnMpO1xuICAgICAgaWYgKCFyZXNwb25zZSkgcmV0dXJuO1xuICAgICAgcmV0dXJuIHNvY2tldC5zZW5kKHRoaXMuZGF0YVBhY2suZW5jb2RlKHJlc3BvbnNlKSwgbXNnX29wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIFJ1bnMgYSBkZWZpbmVkIFJQQyBtZXRob2QuXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZSAtIGEgbWVzc2FnZSByZWNlaXZlZFxuICAqIEBwYXJhbSB7T2JqZWN0fSBzb2NrZXRfaWQgLSB1c2VyJ3Mgc29ja2V0IGlkXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlcyBpZGVudGlmaWVyXG4gICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAgKi9cbiAgYXN5bmMgX3J1bk1ldGhvZChtZXNzYWdlLCBzb2NrZXRfaWQsIG5zID0gXCIvXCIpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDApLFxuICAgICAgICBpZDogbnVsbFxuICAgICAgfTtcbiAgICBpZiAobWVzc2FnZS5qc29ucnBjICE9PSBcIjIuMFwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMCwgXCJJbnZhbGlkIEpTT04gUlBDIHZlcnNpb25cIiksXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgaWYgKCFtZXNzYWdlLm1ldGhvZClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDIsIFwiTWV0aG9kIG5vdCBzcGVjaWZpZWRcIiksXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlLm1ldGhvZCAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDAsIFwiSW52YWxpZCBtZXRob2QgbmFtZVwiKSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICBpZiAobWVzc2FnZS5wYXJhbXMgJiYgdHlwZW9mIG1lc3NhZ2UucGFyYW1zID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMCksXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBcInJwYy5vblwiKSB7XG4gICAgICBpZiAoIW1lc3NhZ2UucGFyYW1zKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMmUzKSxcbiAgICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICAgIH07XG4gICAgICBjb25zdCByZXN1bHRzID0ge307XG4gICAgICBjb25zdCBldmVudF9uYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzKTtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICBjb25zdCBpbmRleCA9IGV2ZW50X25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IHRoaXMubmFtZXNwYWNlc1tuc107XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHRzW25hbWVdID0gXCJwcm92aWRlZCBldmVudCBpbnZhbGlkXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVzcGFjZS5ldmVudHNbZXZlbnRfbmFtZXNbaW5kZXhdXS5wcm90ZWN0ZWQgPT09IHRydWUgJiYgbmFtZXNwYWNlLmNsaWVudHMuZ2V0KHNvY2tldF9pZClbXCJfYXV0aGVudGljYXRlZFwiXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDYpLFxuICAgICAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ja2V0X2luZGV4ID0gbmFtZXNwYWNlLmV2ZW50c1tldmVudF9uYW1lc1tpbmRleF1dLnNvY2tldHMuaW5kZXhPZihzb2NrZXRfaWQpO1xuICAgICAgICBpZiAoc29ja2V0X2luZGV4ID49IDApIHtcbiAgICAgICAgICByZXN1bHRzW25hbWVdID0gXCJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBzdWJzY3JpYmVkIHRvIGV2ZW50XCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZXNwYWNlLmV2ZW50c1tldmVudF9uYW1lc1tpbmRleF1dLnNvY2tldHMucHVzaChzb2NrZXRfaWQpO1xuICAgICAgICByZXN1bHRzW25hbWVdID0gXCJva1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgcmVzdWx0OiByZXN1bHRzLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5tZXRob2QgPT09IFwicnBjLm9mZlwiKSB7XG4gICAgICBpZiAoIW1lc3NhZ2UucGFyYW1zKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMmUzKSxcbiAgICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICAgIH07XG4gICAgICBjb25zdCByZXN1bHRzID0ge307XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXSkge1xuICAgICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcInByb3ZpZGVkIGV2ZW50IGludmFsaWRcIjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdLnNvY2tldHMuaW5kZXhPZihzb2NrZXRfaWQpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwibm90IHN1YnNjcmliZWRcIjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXS5zb2NrZXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcIm9rXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICByZXN1bHQ6IHJlc3VsdHMsXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gXCJycGMubG9naW5cIikge1xuICAgICAgaWYgKCFtZXNzYWdlLnBhcmFtcylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDQpLFxuICAgICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW21lc3NhZ2UubWV0aG9kXSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMSksXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgaWYgKHRoaXMubmFtZXNwYWNlc1tuc10ucnBjX21ldGhvZHNbbWVzc2FnZS5tZXRob2RdLnByb3RlY3RlZCA9PT0gdHJ1ZSAmJiB0aGlzLm5hbWVzcGFjZXNbbnNdLmNsaWVudHMuZ2V0KHNvY2tldF9pZClbXCJfYXV0aGVudGljYXRlZFwiXSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDUpLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW21lc3NhZ2UubWV0aG9kXS5mbihcbiAgICAgICAgbWVzc2FnZS5wYXJhbXMsXG4gICAgICAgIHNvY2tldF9pZFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFtZXNzYWdlLmlkKSByZXR1cm47XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBjb2RlOiAtMzJlMyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm5hbWUsXG4gICAgICAgICAgICBkYXRhOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZDogbWVzc2FnZS5pZFxuICAgICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIW1lc3NhZ2UuaWQpIHJldHVybjtcbiAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IFwicnBjLmxvZ2luXCIgJiYgcmVzcG9uc2UgPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLm5hbWVzcGFjZXNbbnNdLmNsaWVudHMuZ2V0KHNvY2tldF9pZCk7XG4gICAgICBzW1wiX2F1dGhlbnRpY2F0ZWRcIl0gPSB0cnVlO1xuICAgICAgdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLnNldChzb2NrZXRfaWQsIHMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgIHJlc3VsdDogcmVzcG9uc2UsXG4gICAgICBpZDogbWVzc2FnZS5pZFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICogR2VuZXJhdGUgYSBuZXcgbmFtZXNwYWNlIHN0b3JlLlxuICAqIEFsc28gcHJlcmVnaXN0ZXIgc29tZSBzcGVjaWFsIG5hbWVzcGFjZSBtZXRob2RzLlxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBuYW1lc3BhY2VzIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICovXG4gIF9nZW5lcmF0ZU5hbWVzcGFjZShuYW1lKSB7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25hbWVdID0ge1xuICAgICAgcnBjX21ldGhvZHM6IHtcbiAgICAgICAgX19saXN0TWV0aG9kczoge1xuICAgICAgICAgIGZuOiAoKSA9PiBPYmplY3Qua2V5cyh0aGlzLm5hbWVzcGFjZXNbbmFtZV0ucnBjX21ldGhvZHMpLFxuICAgICAgICAgIHByb3RlY3RlZDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNsaWVudHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBldmVudHM6IHt9XG4gICAgfTtcbiAgfVxufTtcbnZhciBSUENfRVJST1JTID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbLTMyZTMsIFwiRXZlbnQgbm90IHByb3ZpZGVkXCJdLFxuICBbLTMyNjAwLCBcIkludmFsaWQgUmVxdWVzdFwiXSxcbiAgWy0zMjYwMSwgXCJNZXRob2Qgbm90IGZvdW5kXCJdLFxuICBbLTMyNjAyLCBcIkludmFsaWQgcGFyYW1zXCJdLFxuICBbLTMyNjAzLCBcIkludGVybmFsIGVycm9yXCJdLFxuICBbLTMyNjA0LCBcIlBhcmFtcyBub3QgZm91bmRcIl0sXG4gIFstMzI2MDUsIFwiTWV0aG9kIGZvcmJpZGRlblwiXSxcbiAgWy0zMjYwNiwgXCJFdmVudCBmb3JiaWRkZW5cIl0sXG4gIFstMzI3MDAsIFwiUGFyc2UgZXJyb3JcIl1cbl0pO1xuZnVuY3Rpb24gY3JlYXRlRXJyb3IoY29kZSwgZGV0YWlscykge1xuICBjb25zdCBlcnJvciA9IHtcbiAgICBjb2RlLFxuICAgIG1lc3NhZ2U6IFJQQ19FUlJPUlMuZ2V0KGNvZGUpIHx8IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCJcbiAgfTtcbiAgaWYgKGRldGFpbHMpIGVycm9yW1wiZGF0YVwiXSA9IGRldGFpbHM7XG4gIHJldHVybiBlcnJvcjtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG52YXIgQ2xpZW50ID0gY2xhc3MgZXh0ZW5kcyBDb21tb25DbGllbnQge1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzID0gXCJ3czovL2xvY2FsaG9zdDo4MDgwXCIsIHtcbiAgICBhdXRvY29ubmVjdCA9IHRydWUsXG4gICAgcmVjb25uZWN0ID0gdHJ1ZSxcbiAgICByZWNvbm5lY3RfaW50ZXJ2YWwgPSAxZTMsXG4gICAgbWF4X3JlY29ubmVjdHMgPSA1LFxuICAgIC4uLnJlc3Rfb3B0aW9uc1xuICB9ID0ge30sIGdlbmVyYXRlX3JlcXVlc3RfaWQpIHtcbiAgICBzdXBlcihcbiAgICAgIFdlYlNvY2tldCxcbiAgICAgIGFkZHJlc3MsXG4gICAgICB7XG4gICAgICAgIGF1dG9jb25uZWN0LFxuICAgICAgICByZWNvbm5lY3QsXG4gICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbCxcbiAgICAgICAgbWF4X3JlY29ubmVjdHMsXG4gICAgICAgIC4uLnJlc3Rfb3B0aW9uc1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlX3JlcXVlc3RfaWRcbiAgICApO1xuICB9XG59O1xuXG5leHBvcnQgeyBDbGllbnQsIENvbW1vbkNsaWVudCwgRGVmYXVsdERhdGFQYWNrLCBTZXJ2ZXIsIFdlYlNvY2tldCwgY3JlYXRlRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW91dC5qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiV2ViU29ja2V0SW1wbCIsIldlYlNvY2tldFNlcnZlciIsIkV2ZW50RW1pdHRlciIsInVybCIsInYxIiwiV2ViU29ja2V0IiwiYWRkcmVzcyIsIm9wdGlvbnMiLCJEZWZhdWx0RGF0YVBhY2siLCJlbmNvZGUiLCJ2YWx1ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZWNvZGUiLCJwYXJzZSIsIkNvbW1vbkNsaWVudCIsImNvbnN0cnVjdG9yIiwid2ViU29ja2V0RmFjdG9yeSIsImF1dG9jb25uZWN0IiwicmVjb25uZWN0IiwicmVjb25uZWN0X2ludGVydmFsIiwibWF4X3JlY29ubmVjdHMiLCJyZXN0X29wdGlvbnMiLCJnZW5lcmF0ZV9yZXF1ZXN0X2lkIiwiZGF0YVBhY2siLCJxdWV1ZSIsInJwY19pZCIsInJlYWR5IiwicmVjb25uZWN0X3RpbWVyX2lkIiwiY3VycmVudF9yZWNvbm5lY3RzIiwiX2Nvbm5lY3QiLCJjb25uZWN0Iiwic29ja2V0IiwiY2FsbCIsIm1ldGhvZCIsInBhcmFtcyIsInRpbWVvdXQiLCJ3c19vcHRzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJFcnJvciIsIm1lc3NhZ2UiLCJqc29ucnBjIiwiaWQiLCJzZW5kIiwiZXJyb3IiLCJwcm9taXNlIiwic2V0VGltZW91dCIsImxvZ2luIiwicmVzcCIsImxpc3RNZXRob2RzIiwibm90aWZ5Iiwic3Vic2NyaWJlIiwiZXZlbnQiLCJyZXN1bHQiLCJ1bnN1YnNjcmliZSIsImNsb3NlIiwiY29kZSIsImRhdGEiLCJzZXRBdXRvUmVjb25uZWN0Iiwic2V0UmVjb25uZWN0SW50ZXJ2YWwiLCJpbnRlcnZhbCIsInNldE1heFJlY29ubmVjdHMiLCJjbGVhclRpbWVvdXQiLCJhZGRFdmVudExpc3RlbmVyIiwiZW1pdCIsIkFycmF5QnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsInRvU3RyaW5nIiwibm90aWZpY2F0aW9uIiwibGlzdGVuZXJzIiwibGVuZ3RoIiwiT2JqZWN0Iiwia2V5cyIsImFyZ3MiLCJwdXNoIiwiaSIsInRoZW4iLCJhcHBseSIsInJlYXNvbiIsIlNlcnZlciIsIm5hbWVzcGFjZXMiLCJ3c3MiLCJvbiIsInJlcXVlc3QiLCJ1IiwibnMiLCJwYXRobmFtZSIsInF1ZXJ5Iiwic29ja2V0X2lkIiwiX2lkIiwiY2xpZW50cyIsImRlbGV0ZSIsImV2ZW50cyIsImluZGV4Iiwic29ja2V0cyIsImluZGV4T2YiLCJzcGxpY2UiLCJfZ2VuZXJhdGVOYW1lc3BhY2UiLCJzZXQiLCJfaGFuZGxlUlBDIiwicmVnaXN0ZXIiLCJuYW1lIiwiZm4iLCJycGNfbWV0aG9kcyIsInByb3RlY3RlZCIsIl9tYWtlUHJvdGVjdGVkTWV0aG9kIiwicHVibGljIiwiX21ha2VQdWJsaWNNZXRob2QiLCJzZXRBdXRoIiwiX21ha2VQcm90ZWN0ZWRFdmVudCIsIl9tYWtlUHVibGljRXZlbnQiLCJjbG9zZU5hbWVzcGFjZSIsIm5hbWVzcGFjZSIsInZhbHVlcyIsImdldCIsIm9mIiwic2VsZiIsImZuX25hbWUiLCJhcmd1bWVudHMiLCJldl9uYW1lIiwiZXZlbnRMaXN0Iiwic29ja2V0X2lkcyIsImNvbm5lY3RlZCIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJjcmVhdGVFcnJvciIsIm1zZ19vcHRpb25zIiwiYmluYXJ5IiwicmVhZHlTdGF0ZSIsInBhcnNlZERhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJyZXNwb25zZXMiLCJyZXNwb25zZTIiLCJfcnVuTWV0aG9kIiwicmVzcG9uc2UiLCJyZXN1bHRzIiwiZXZlbnRfbmFtZXMiLCJzb2NrZXRfaW5kZXgiLCJzIiwiX19saXN0TWV0aG9kcyIsIk1hcCIsIlJQQ19FUlJPUlMiLCJkZXRhaWxzIiwiQ2xpZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rpc-websockets/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* reexport default export from named module */ _index_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQztBQUVkO0FBQ3ZCLGlFQUFlQSxzQ0FBWUEsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NoYXJweS8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5tanM/YjMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vaW5kZXguanMnXG5cbmV4cG9ydCB7IEV2ZW50RW1pdHRlciB9XG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXJcbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs\n");

/***/ })

};
;